<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对报表进行比率分析]]></title>
    <url>%2F2018%2F07%2F24%2Fratio-analysis%2F</url>
    <content type="text"><![CDATA[​ 什么是比率分析？前面的三张报表，把一个企业从资本，盈利能力，以及风险的角度进行剖析，展示了一个企业的现状。 拿当然，仅仅看到报表里的绝对值数字是不够的，我们还要分析这些数字意味着什么，这个时候就要进行比率分析。 所谓比率分析，其实就是分析各个财务数字之间的比率（ratio）关系。通过对比一家公司同一个比率指标在不同时期的表现，或者对比一家公司的某个比率指标与整个行业平均值，就可以判断出这家公司的财务和经营状况。 另外，需要注意的是，单单比较某一个比率是没有意义的，需要将多个比率结合起来对比才能做出正确的判断。 比率有哪些分类？ 流动性比率 盈利能力比率 营运效率比率 杠杆比率 偿债保障比率 流动性比率流动性流动性，基本可以理解为资产变为现金的速度。一个企业资产变为现金的速度越快，其流动性就越快。那一个企业哪些资产容易变成现金啊？前面我们说过，流动资产是最容易变成现金的。并且，在流动资产里各项的排序，也是按照其变成现金的先后顺序来的–货币资金本身就是现金，存货要生产出来卖掉，才有可能变成现金。 流动比一般来说，流动资产转化成现金后，多数情况下是用来偿还流动负债。因此，我们可以用流动资产除以流动负债来得到流动比。 流动比率=流动资产/流动负债 流动比： Current Ratio 显然,流动比越高，偿债能力越强。像苹果这种公司有450亿美金现金在账面上的公司，是几乎不用担心他换不上账的（当然，苹果公司也有很多流动负债） 速动比上面说过，流动资产里最不容易变成现金的是存货。存货先要经过生产，销售环节，才有可能变成应收或者货币资金。更何况，存货很有可能因为市场环境或者公司策略的原因，要很长时间才能被销售掉。所以，把存货从流动资产中拿走，用剩下的流动资产除以流动负债，就得到的速动比。 速动比=（流动资产-存货）/流动负债同样，速动比越高，代表公司资产的流动性越强。 盈利能力比率盈利能力是对利润表进行的分析。 毛利毛利=(营业收入-营业成本)/营业收入 净利率净利率= 净利润/营业收入当然，净利率越高越好。但是呢，我们前面说过，净利润高不一定是真金白银，有可能是公允价值高，所以不一定能完全说明问题。因此，考察营业利率也很必要。 营业利率营业利率=营业利润/营业收入 这个指标越高，就说明营业活动收益越高 总资产报酬率又被称为ROA，代表的是单位资产所能取得的利润回报ROA=净利润/总资产 净资产报酬率又被称为ROE，代表的是单位净资产（总资产-负债），也就是单位股东权益所能获得的利润回报。ROE=净利润/股东权益 营运效率比率基本上可以这么理解，营运效率指的就是公司的各种资源的效率，也就是周转速度。周转的越快，代表营运效率是越高的。 应收账款周转率基本上来说，这就是企业在实际运营过程中最关心的周转率之一。应收账款代表的是企业的赊销，这个数字越低，企业坏账的风险也会越低。应收账款周转率的公式如下： 应收账款周转率=营业收入/应收账款 我们看到，这个比率实际上是把利润表和资产负债表的相应数字的结合。然而，利润表反映的是一段时期之内的表现，而资产负债表反映的是某个时间节点的表现。因此，为了统一，应收账款需要使用期初和期末的应收账款的平均值。 应收账款周转率代表一年之内应收账款的周转次数。于是，用一年的天数，除以应收账款周转率，便可以得到平均账期。 存货周转率代表一年之内存货的周转次数。 存货周转率=营业成本/存货 同样的，在这个公式里的存货需要使用期初和期末的平均数。 固定资产周转率代表单位固定资产所能产生的营业收入。 固定资产周转率=营业收入/固定资产 总资产周转率代表单位资产所能产生的营业收入。这个数值当然是越高越好。 总资产周转率=营业收入/总资产 不要忘记使用期初和期末的平均值 重新审视ROA有了上面这些比率，我们就可以重新审视ROA了。 也就是说，总资产报酬率等于利润率与总资产周转率的乘积。 这也就可以解释提高资产报酬率的两种方式：提高利润率(比如生产高端产品)，或者加快资产周转(薄利多销)。 杠杆比率一个公司在发展的过程中，必不可少需要使用杠杆。看看15年股灾的时候证监会去杠杆引起了多大的震动，就知道杠杆比率有多重要。 总负债比资产负债表的右边，是负债和股东权益，分别代表了债主和股东的利益。因为企业在还完债之后才可以对股东进行分红，因此很有必要考察企业的负债比。 总负债比=负债/总资产 权益乘数从另外一个方面显示杠杆比以及负债比。 权益乘数=总资产/股东权益 权益乘数越高，就代表资产中股东权益的比例越小，也就是负债的比例越高，财务风险越大。 偿债保障比率这个比率和流动性比率相仿，表示的都是偿债能力。 利息保障倍数使用息税前利润(EBIT)与利息的比值来表示公司偿还利息的能力。 利息保障倍数=EBIT/利息]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>报表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[财务报表之现金流]]></title>
    <url>%2F2018%2F07%2F13%2Fcash-flow%2F</url>
    <content type="text"><![CDATA[​ 为什么需要现金流量表？在研究利润表的时候我们说过，利润高并不等于现金多。举个最简单的例子，营业收入高，说明产品卖出去的多，但是，产品卖出去的多不代表能立刻收回账来。收回账来也不一定收回的是现金，还有可能是6个月的承兑。 然而，一个企业在运营的时候需要花现金的地方简直太多了。企业每个月都会要付出利息，总不能用银行承兑来抵利息吧？就算企业可以赊账购买原料，但不可能所有供应商都愿意让企业赊账吧？ 再举个更简单的例子：多数销售人员在大学刚毕业的时候，没攒下什么钱，可偏偏要经常出差，所有费用都要自己先垫付，然后找公司报销。要报销的钱，从财务上来看，都是应收账款。要报销的数额越大，就相当于公司占用了越多的个人现金。如果个人积蓄不够雄厚，过几个月可能就没有钱付房租了。 类比过来，企业的经营也是如此。资产负债表能看到企业的家底，利润表能看到企业到底赚不赚钱，现金流量表则是从运营风险的角度来看企业的运转是否正常。 现金流量表是怎么组织的？一个基本的概念是，一个企业始终在进行经营，投资和融资活动。那么，把每一种活动的每一笔现金流入和流出都记录下来，最后再根据企业活动类型（经营，投资，融资）以及流向（流入，流出）来进行分类，就可以得到一张现金流量表。 没错，现金流量表就是把现金（注意一定是现金）的流水账，分分类，然后用类似数据透视表（Pivot Table）的技术进行汇总。 经营，投资和融资各包括什么活动？大致上，这三项活动涉及的现金流入流出可以这样来划分： 经营活动 流入 销售 税收（退税） 流出 采购 税收（交税） 人工 投资活动 对内投资 流入 处置资产 流出 购建固定资产（注意购买固定资产是投资，不是经营活动） 对外投资 流入 处置收益 流出 投资 融资活动 债务融资 流入 借款，融入资本 流出 还本付息 股权融资 流入 融入资金 流出 分红 现金流量表与资产负债表的关系是什么？现金流量表展示的也是某个时间段内，资产负债表中货币资金的变化。也就是说，现金流量表完全是在详细的解释货币资金发生了什么变化，这些变化是由什么造成的。 再把利润表也拉进来，我们就可以得到这三张报表之间最直截了当的关系：资产负债表是主体，利润表和现金流量表从盈利能力以及企业风险的角度来更深层次揭示企业的财务运转情况。]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>报表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[财务报表之利润表]]></title>
    <url>%2F2018%2F07%2F13%2Fincome-statement%2F</url>
    <content type="text"><![CDATA[​ 前面我们说过，资产负债表是反映一个企业家底的表格。既然如此，为了更深入地了解企业，很自然有一个问题就冒了出来： 企业的钱都是从哪里赚来的？ 资产负债表的股东权益里有一项叫做未分配利润，上面这个问题其实就是问：未分配利润是怎么来的？ 所以，我们需要深入研究一个企业的收入，以及盈利能力。利润表就是用来干这个的。 利润表是怎么做出来的说白了，利润表就是收入减去各种费用得来的，这和我们平时算账差不多。 利润表里的各项元素有下面这些： 营业收入这个术语一看就知道是属于经营活动产生的收入。这里要注意一点：营业收入是不包含增值税的。具体点讲，增值税是价外税，并且是流转税，实际上最终都是由消费者承担的，所以增值税不影响最终损益。也就是说，增值税在利润表中是不体现的。 营业成本生产或者营业所产生的成本。产生成本的项目很多，也可以分成两种： 可变成本简单点理解，可变成本就是跟随产品产量变化的成本。例如，生产一台电脑需要很多芯片，电脑生产的越多，就需要越多芯片。如果不生产电脑，就不需要付芯片的钱。在上面这个例子里，芯片就属于电脑生产的可变成本。 固定成本简单点理解，公司生产或不生产，固定成本就在那里，不多不少。举个例子，为了生产电脑需要购买流水线，价格1000万，折旧5年。那么不管公司生不生产电脑，固定资产折旧的成本每年都是200万（按照线性折旧来计算）。假设一条流水线每年能生产1万台电脑，每一天电脑的芯片成本1000元（不考虑其他可变成本），那么公司出来的电脑需要卖至少要卖200/1+1000=1200块才能保本。但是在某些极端情况下，如果市场下游需求不好，很有可能1100块也可以卖，每台电脑还可以赚100块来抵消一部分固定成本。 营业税金及附加在中国有一个特色税种，叫做营业税。营业税是一种价内流转税，以前一般都使用在服务业。营业税的特点是：企业在经营，不管有没有赚钱，都得交营业税。不过16年5月国家全面实施了营改增，营业税算是退出历史舞台了，这个科目也变成了税金及附加。附加又指的是什么呢？调整过后的附加包括：消费税、城市维护建设税、资源税、教育费附加及房产税、土地使用税、车船使用税、印花税等 营业费用在生产和销售过程中所产生的费用。一般包括： 清关报关费用 物流费用 货物保险 由销售活动所带来的费用，如销售人员的差旅费用，工资等 广告费 管理费用与企业的管理环节相关的费用。包括： 管理部门职工工资 管理人员的差旅费用 研发费用 咨询费 公司办公楼的折旧 财务费用企业经营过程中筹资或者银行存款所发生的费用，包括： 利息支出 利息收入 手续费 汇兑损益 上面的这些项目，是企业基本经营和筹资方面所产生的收益部分，当然，其他因素也能影响企业的利润，这些又包括： 投资收益投资收益是企业营业利润当中的一部分，指的是企业投资所产生的收益，包括股利，分红等等。 资产减值损失如果资产相对于历史成本发生减值，就需要把减值也记录在利润表里。当然，如果资产升值的话，利润表是不做记录的。 公允价值变动收益对于金融资产来说，是有公允价值(Fair Value)的，如果企业所拥有的金融或者房地产资产比上一期末有变化，也需要把变化的值记录下来。 有了上面这些信息，我们就可以得到企业的营业利润了。 营业利润通过简单的数学计算就可以得到： 1营业利润=营业收入-营业成本-税金及附加-营业费用-管理费用-财务费用+投资收益-资产减值损失+公允价值变动收益 除了正常的营业利润，企业在一个周期内可能会有一些其他收入或者支出，而这些收入或支出不一定是由于营业带来的。 营业外收入企业在营业范围以外所获得的收入，例如： 获得政府补贴 出售无形资产（专利，商标等） 处置固定资产收入 罚款收入 营业外支出与上面营业外收入对应，指企业在经营范围以外的支出，例如： 处置固定资产损失 公益捐款 非常损失（例如火灾等等） 固定资产盘亏 有了营业外的收入和支出，我们就可以再进一步，获得企业利润总额了。 利润总额1利润总额=营业利润+营业外收入-营业外支出 所得税费用这个不需要解释，赚了钱，还能不交税？中国企业所得税的税率是25%，老老实实交税吧！这里要注意一点：所得税的税率是25%，并不代表拿到手里的钱一定是利润总额的75% 应税所得是税法规定的，可能会高于利润总额 净利润交完税了，剩下的就是净利润了。1净利润=利润总额-所得税费用 利润不等于现金流正常来看，在企业的资产负债表上的股东权益部分，是可以体现利润情况的。如果只看一个总数，利润很高，会很亮眼。但是，这些利润是从哪来的？这些高利润是否能够持久维持？这两个问题仅仅看一个数字是看不出来的。所以，我们需要有一张利润表，把企业各个方面的盈利能力一一量化，这样我们就会对企业来钱的能力有更深刻的认识。 但是，利润高和有钱不是一回事！ 我们看到前面，利润高的原因可能有很多： 营业收入高 一般费用低 公允价值变动收益多 投资收益多 这里面： 公允价值变动收益可能根本不会立刻带来现金 营业收入高，不代表所有账款都已经收回来 所以，光有资产负债和利润表并不能体现出企业的货币资金的情况，这个时候就需要一张现金流量表了。 利润表是一个阶段企业利润的显示我们前面说过，资产负债表显示的是某一个特定的时间点，企业所拥有的资产情况。而利润表不同，利润表表示的是一个时间段内（通常是指1个季度，半年，3个季度，全年），公司的盈利情况。]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>报表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[财务报表之资产负债表]]></title>
    <url>%2F2018%2F07%2F04%2Fbalance-sheet%2F</url>
    <content type="text"><![CDATA[​ 企业的主要行为是什么？ 经营 投资 融资 资产负债表是什么？反映一个企业所拥有的资产的，也就是企业家底的一个表格。资产就是是可以货币表示的东西资产仅仅是企业资源的一部分 资产负债表由哪些构成？资产从流动性上来看，两大类，6小类 流动资产一般指一年（或者一个经营周期）内可以转化成现金的资产流动资产包括三项主要的资产 货币资金 债券 应收账款 预付账款 存货 非流动资产一般指一年（一个周期）以上才可以转化成现金的资产 长期投资比较重要的是长期股权投资，经常用来做文章 固定资产 固定资产 在建工程 固定资产清理 投资性房地产 无形资产以及其他非流动资产 无形资产 开发支出 商业信誉等 从对利润的贡献方式来看的话，也分两类： 经营资产 货币 债券 存货 固定资产 无形资产投资资产 可供出售金融资产 持有至到期的投资 长期股权投资 资产负债表的右边，就是写明了资产的归属，资产的归属有两种人： 债权人 股东 负债流动负债: 企业在一年（一个周期）之内必须要支付的负债 短期借款 应付账款 预收账款 非流动负债：一年以后才需要偿还的负债 长期借款 长期应付款 其他非流动资产 股东权益 实收资本/股本股本是针对上市公司而言的，普通的公司叫实收资本。在中国就是注册资本，股本的总额体现出了公司对外承担的法律责任的上限 资本公积股东入资导致超过股本，多出来的部分就放到资本公积里 盈余公积中国规定企业10%的利润一定要存到盈余公积里 未分配利润公司利润先留10%到盈余公积，然后剩下的部分再分红，最后还剩下的部分就叫未分配利润 一个守恒定律资产= 负债+股东权益，放之四海而皆准 资产形态的变化，不影响负债和股东权益的变化。也就是说，用现金投资了固定资产，变化的只是资产部分的内部，而负债和股东权益是不会变的。如果资产小于负债，导致股东权益为负，就是资不抵债 资产负债表意味着什么？资产负债表显示的只是某个特定时刻，例如年末或者季度末，公司整体的家底。但在这一年里发生了什么？资产负债表上是看不出来的。结果导向，是资产负债表最大的特点。]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>报表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续复利的计算]]></title>
    <url>%2F2018%2F06%2F25%2Fcontinuous-compounding%2F</url>
    <content type="text"><![CDATA[​ 我们前面说过，时间是投资的朋友，其实也就是说，复利可以生成更多的终值。如果现在银行定期的年存款利率为5%，并且你计划存12000块到银行存款。现在有两家银行可选，一家银行半年结一次息，另外一家银行3个月结一次息。如果想到年底获得最大的终值，应该怎么选呢？ 前面我们说过，终值的计算公式是这样子的： 其中i是年华利率 n是以年计算的期数 如果把一年分成m期，那么每期的收益率就变成了i/m,总共的期数就变成了nm。上面的公式就变成了： 假设银行允许你极限操作，每年可以分成的期数m允许为无穷大，我们队上面公式求个极限： 也就是说，在每年可以分成无穷多期的情况下，每年的收益可以逼近e^i-1 最后，我们用Excel来模拟一下一年分成多期的情况。下面这个图列出了每年分的期数，以及对应的终值。可以看得出来，期数越多，终值是越高的。不过貌似分52期和分一期最后只差了0.1%，资金量小的时候，差别不大，但当资金量大的时候，这0.1%还是很可观的。 总结 e^i-1这个极限值要记住]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递增年金的终值和现值]]></title>
    <url>%2F2018%2F06%2F25%2Fgrowing-annuities%2F</url>
    <content type="text"><![CDATA[​ 上一篇文章中，我们探讨了货币的时间价值，以及年金在每期数额相等的情况下，所对应的现值和终值。实际情况中，我们也会经常遇到年金不断增长的情况。比如说下面这个例子：现在有一笔钱要存入银行，存款利率为5%。你准备在未来6年每年提出10000块钱用作孩子的学费。然而，学费以每年3%的速度增长。那么，你现在需要存入多少钱才可以？ 传统数学方法计算现值我们假设年金每年的增长率为g(上面例子为3%)投资利率为i(上面例子为5%)起始年金为pmt(上面例子为10000)期数为n(上面例子为6) 在这种情况下，年金的示意图为： 每年年金对应的PV计算如下： 把每年的PV相加，利用等比数列的求和公式，就可以得到总的PV 用Excel来计算如下： 另外一种思路这个公式看起来也很复杂，有没有别的思路来看待这个问题呢？ 如果我们先不考虑年金，只计算单笔资金的情况： n年后，单笔资金的FV为 PV(1+i)^nn年后，资金购买力下降（可以理解成通货膨胀），单笔资金因为通货膨胀所造成的贬值因子为：(1+g&gt;^nn年后，资金的实际购买力为：PV(1+i)^n/(1+g)^n这个公式看起来很眼熟，把他和正常的FV=PV(1+i)^n相比，就相当于是实际的利率为： 题外话：如果你的资产增长率低于通货膨胀率的话，那你的资产增长的实际利率就变成负值，被割韭菜是不可避免了。 使用PV函数计算有了实际利率，我们就可以使用Excel自带的PV函数来计算现值了。在计算的时候，还有一点要注意：我们在案例中的PMT是从第一期开始计算的，需要把它修正为第0期。 怎么修正呢？直接用第一期的PMT除1+g即可。 我们把上面的参数带入到Excel中，就可以直接用PV计算出结果。 计算终值我们有了上面的现值公式，又知道了现值和终值的关系，所以，直接把现值乘上(1+i)^n即可。于是，终值的公式就成为： 这里要注意的是，不能使用上述计算PV的参数来计算FV。最好的方法，还是把上面的PV计算出来之后，再乘(1+i)^n 总结 递增年金的概念，以及计算其现值和终值的方法]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[货币的时间价值]]></title>
    <url>%2F2018%2F06%2F24%2Ftime-value-of-money%2F</url>
    <content type="text"><![CDATA[​ 我们在不少地方应该都听说过，时间是投资的朋友。金融学里一个很重要的思想，就是钱生钱。简单的说，今天的100块，和一年后的100块，从价值上来说是不一样的。因为，今天我可以用100块去投资，哪怕是投风险最低，收益最低的国债，明年怎么也能拿到103块左右。 从这个例子来说，现在这个时间点，这100块钱就值100块，这个称作现值。一年后，变成了103块，这103块就是一年以后的终值。 现值：PV Present Value终值：FV Future Value 现值和终值的关系对于一笔数额为m的投资，如果采用复利的方式，每年利率为i，如何计算n年以后的终值呢？ 第一年的FV为：m(1+i) 第二年的FV为：m(1+i)(1+i)=m(1+i)^2 … 第n年的FV为：m(1+i)^n 也就是说，FV=PV(1+i)^n。这样我们就得到了一个现值PV和终值FV的计算公式，就可以利用现值PV，计算终值FV，或者用终值FV来计算现值PV。 用Excel计算现值和终值Excel作为金融学的好基友，提供了计算现值PV和终值FV的函数。内置的终值函数FV截图如下，有5个参数： Rate表示每一期的利率 Nper表示一共的期数 Pmt表示每期存入或支出的资金数量，在单个资金的计算里，设置为0 Pv表示资金的现值 Type与Pmt相关，在这里设置为默认为0 举个例子：现在每个月工资10000元，假设工资每年增长7%，那么20年以后，你的工资会是多少钱？ 如下图，我们直接用v(0.07,20,0,-10000,0)计算即可。注意，上面公式的PV我们设置为-10000,因为Excel自动把PV或者FV默认为现金流出。关于正负号的问题，可以参考Quora上的这篇文章 同样道理，Excel也提供了一个现值函数PV，用来求给定终值FV对应的现值。我们看，PV函数的参数和FV函数基本差不多，用法也差不多。 再举个例子： 你准备一次性拿出一部分钱投资，如果投资利率为7%，你想要在30年后拿到100万，那么现在应该投资多少钱？ 同样道理，我们用pv(0.07,30, 0,-1000000,0)即可。 年金的现值和终值上面我们接触的情况，都是单笔投资，对于一定年限的现值或者终值。在现实生活中，我们也经常会遇到定期投资一定数额（存款定投）或者是定期支出一定数额（房贷车贷）这种情况。这种一定时间内一定期数的款项，被称作年金。 年金：Annuitites 下面这个图表示了一个最简单的年金示意图：每年存入100块，连续存5年。 上面这个年金对应的现值应该怎么计算呢？我们需要按照每一期来计算。 第一期对应的PV为100/(1+i) 第二期对应的PV为100/(1+i)^2 … 第五期对应的PV为100/(1+i)^5 总的现值等于上面5个PV的加和。上面的步骤可以抽象成这个公式： 如果每次的pmti相同的话，我们可以使用等比数列求和公式来得到年金的现值： 我们上面说过，现值和终值的关系是这样的： 再结合上面年金现值的公式，因此年金终值的公式就成为： 看下面这个例子： 现在你准备给孩子在银行买一笔理财金，从明年开始，每年提取出10000块用于孩子的学费，一共6年。银行的理财收益率为5%的情况下，应该买多少？ 我们用上面现值的公式，很容易就可以得到: 再看一个例子： 工作后，你准备每年存10000块到理财产品，年化收益率为5%，那么30年后，你会有多少钱？利用年金的终值公式，我们可以计算出来。 上面两种计算方法公式看起来很麻烦，万一记不住怎么办？ 其实我们在前面计算FV和PV时，提到过有一个PMT参数。我们在前面所讲的年金，实际上就是PMT参数。 因此，如果要计算上面含有年金的PV，可以直接使用这个公式： 1PV(0.05,6,-10000)=50757 类似的，可以用FV结合PMT参数直接求年金的终值。 现值终值全家桶函数不知道大家发现没有，我们上面反复在求FV和PV，其实最终涉及到这么几个参数： PV FV Rate NPer PMT 其实，这5个参数，知道其中任意4个，求剩下的一个，Excel都有相对应的函数。 最常用的应该是PMT和Rate函数。 在这篇文章中，我们计算了等额本息方法下的还款额。实际上我们想一下，要求解的还款额其实就相当于是年金。现值为1500000，终值为0（想象成银行在你这存款）所以，我们不需要用复杂的公式，直接用：1PMT(0.049/12, 360, -1500000, 0) 即可求出每个月要还款7960元。 Rate函数，用来求给定了现值，终值，年金，和期数后，所要求的利率。一个更常用的用法应该是求复合增长率。例如，如果你的公司要求业绩5年翻番，那么平均每年需要增长多少？对于上面这个问题，我们直接用： 1=RATE(5,0,-1,2) 可以得到，每年的增长率为14.87% 总结现值和终值是财务分析里最最基础的概念，如果能深刻理解钱生钱这个理念的话，本篇文章的所有内容也就都不难理解了。]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Excel计算还款之理论基础]]></title>
    <url>%2F2018%2F06%2F23%2Fexcel-loan-repayment-basic%2F</url>
    <content type="text"><![CDATA[​ 新开一部分专题，来讲讲Excel在金融建模中的应用。 计划在这个专题里，跟随经典的教材，讲一些日常生活中我们常见的可以和财务以及Excel结合的例子。一方面，可以提高自己的金融知识水平，另一方面，也可以顺手解决一些实际需求。 今天先从还款，也就是loan repayment讲起。 话说小明毕业后来到魔都，经过5年奋斗，终于省吃俭用的攒下了10万块钱。加上家里父母支持的90万，凑够了100万首付。他看中的房子标价250万，他还需要贷款150万。 问题来了，如果小明商业贷款的利率是每年4.9%，计划30年还清，那他每个月需要还多少月供？ 在开始计算之前，我们需要弄清楚偿还贷款的两种方式：等额本金和等额本息法。 等额本金：Even Principal Payments等额本息： Even Total Payments 等额本金等额本金的概念是：每个月的还款包括两部分：本金部分和利息部分。每次还款中的本金部分的数额都是相同的，而利息部分则等于剩余未偿还的本金所产生的利息。以上面的例子为例： 贷款总额150万，360个月偿还，每个月需要还1500000/360=4167元本金 第一个月本金基数为150万，所产生的利息为：1500000*0.049/12=6125 所以第一个月的偿还总额为：4167+6125=10292 到了第2个月 需要偿还的本金依旧是4167元 因为上一个月已经还了4167元本金，因此剩余的本金产生的利息为：(1500000-4167)*0.049/12=6108 所以第二个月的还款总额是：4167+6108=10275 以此类推，一直到最后一个月。 算一算我们就看出来了，等额本金法每个月的还款额是逐渐减少的。每个月减少的数额实际上就是上个月偿还的本金额一个月所产生的利息。用上面的例子来计算，就是4167*0.049/12=17。 用Excel模拟计算出来的结果如下： 等额本息等额本息的概念是：每期还款的数额是不变的。每期还款后，剩下的本金加上当期产生的利息作为一个整体继续计息。 这种方式就是利滚利 假设每期的利率为r贷款金额为p 第一期还款x元，剩余欠款为p(1+r)-x 第二期还款x元，剩余欠款为(p(1+r)-x)*(1+r)-x = p(1+r)^2 -x(1+r) -x 第三期还款x元，剩余欠款为p(1+r)^3- x(1+r)^2- x(1+r) -x 第n期还款x元，剩余欠款为 p(1+r)^n - x(1+r)^(n-1) -x(1+r)^(n-2) - ... - x(1+r) -x 到了第n期，剩余欠款就为0了，因此 p(1+r)^n - x(1+r)^(n-1) -x(1+r)^(n-2) - … - x(1+r) -x = 0利用上面这个公式，以及等比公式求和公式，我们可以推导出： 回到我们题目中的例子，如果采用等额本息的方法，每个月的还款额为：1500000*0.049/12*(1+0.049/12)^360/((1+0.049/12)^360-1)=7691 用Excel模拟出来的结果如下： 两种方法的比较 从实际还款总额来看的话，等额本金法比等额本息法要少。我们上面这个例子，等额本金最终所有还款额为260万，而等额本息的还款总额为286万 从每期还款数目来看的话，等额本金法最初的单期还款数额比等额本息要高很多，初期的资金压力会比较大，但其还款金额会随着时间递减 上面公式看起来都蛮复杂的，那么怎么样用Excel来计算呢？这个我们在下一节继续研究。]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同样的Access，不一样的数据类型]]></title>
    <url>%2F2018%2F06%2F21%2FAccess-version-data-type%2F</url>
    <content type="text"><![CDATA[​ 最近算是和ACCESS彻底杠上了。 其实我一般是不太喜欢用ACCESS的，因为自己不是专门做数据库的，用ACCESS总有一种杀鸡用牛刀的感觉。 不过最近做一个项目，指定要用ACCESS。于是在自己的私人电脑上做了一个小的demo文件。然而，这个文件拷贝到公司电脑上，打开时却报错了： 看这个报错，貌似是因为公司电脑的ACCESS版本不够高？查看了一下公司电脑的版本，已经是2016版了。难道还有比2016版还要高的版本？ 还是老套路，到MSDN上面搜一个报错关键词，查到这个页面，里面提到： This issue occurs if you try to open a database that contains a table that uses the BigInt data type. BigInt support was added to Access 2016. BigInt appears within the table’s data type as Large Number. 也就是说，ACCESS2016版里新增了一个数据类型叫BigInt。如果用以前的ACCESS版本来打开含有BigInt类型的文件，就会报错。 那么问题来了，我的公司电脑已经是2016版的，里面有没有Large Number这个数据类型呢？看了一下，居然没有！为什么呢？ 还有一点：MSDN里说，如果要打开的表格里使用了BigInt这个类型才会报错，可是我的原始文件里也没有用到这个数据类型，为什么也会报错呢？ 这两个问题始终没有得到答案。最后的处理方式是：把私人电脑里的ACCESS数据导出为Excel文件，然后导入到公司电脑上。这也算是一种曲线救国的方式了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Access</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用ADO导入CSV后部分数据变成NULL，怎么破？]]></title>
    <url>%2F2018%2F06%2F20%2FADO-Text-Driver-Data-Type%2F</url>
    <content type="text"><![CDATA[​ 最近要处理一些数据量比较大的CSV文件，本着能不用ACCESS就不用ACCESS的原则，使用了VBA+ADO联用的方法。 CSV，Comma Separated Value，是一种用逗号分隔不同的值，来保存数据的文本文件 ADO, Active Data Object，可以简单的看作是操作数据库的接口 出现了什么问题？首先要做的一步是把CSV中的数据读取到工作表里。鉴于这不是一篇入门的文章，我们就不在这里介绍基础内容了。 现有的p.csv文件是这个样子： 用下面的这段程序，可以直接把CSV中的数据读入到工作表里。 12345678910111213141516171819Option ExplicitSub main() LoadData "p.csv"End SubPrivate Sub LoadData(strCSVPath As String) Dim strSQL As String, strConnection As String Dim oRst As ADODB.Recordset strConnection = "Provider=Microsoft.ace.oledb.12.0;" &amp; _ "Data Source=" &amp; ThisWorkbook.Path &amp; ";" &amp; _ "Extended Properties= 'text;HDR=Yes;IMEX=1;FMT=Delimited(,)';" Set oRst = New ADODB.Recordset strSQL = "SELECT * FROM " &amp; strCSVPath oRst.Open strSQL, strConnection, adOpenStatic, adLockReadOnly Sheet1.Range("a1").CopyFromRecordset oRst oRst.Close Set oRst = NothingEnd Sub 上面这段代码，可以把当前工作簿目录下的p.csv中的数据内容导入到sheet1工作表里。查看sheet1工作表，发现一个问题：有些单元格是空的，比如第189，195,196行。 再返回到源文件查看对应的行，第一眼看上去是有数据的啊，见下图： 又重复运行了几次脚本，复制出来的数据始终有空行，百思不得其解。 原因在哪里？又盯着看了一会，似乎看出了点端倪。不能被显示出来的数据貌似都很大，都是E9数量级。但看第188行，1.22E9是可以正常显示的。 感觉显示为空单元的数字都太大了，所以没有显示出来。经过LEAF大神的提醒，可以使用Fields.Type来查看数据类型。上面的代码修改为： 1234567891011121314151617181920212223242526Option ExplicitSub main() LoadData "p.csv"End SubPrivate Sub LoadData(strCSVPath As String) Dim strSQL As String, strConnection As String Dim oRst As ADODB.Recordset Dim i As Integer strConnection = "Provider=Microsoft.ace.oledb.12.0;" &amp; _ "Data Source=" &amp; ThisWorkbook.Path &amp; ";" &amp; _ "Extended Properties= 'text;HDR=Yes;IMEX=1;FMT=Delimited(,)';" Set oRst = New ADODB.Recordset strSQL = "SELECT * FROM " &amp; strCSVPath oRst.Open strSQL, strConnection, adOpenStatic, adLockReadOnly '以下为新增代码 '======== For i = 0 To oRst.Fields.Count - 1 Debug.Print oRst.Fields(i).Type, oRst.Fields(i).Name Next i '======== '以上为新增代码 Sheet1.Range("a1").CopyFromRecordset oRst oRst.Close Set oRst = NothingEnd Sub 到立即窗口查看，打印出了下面的内容：123202 账户简称3 金额（元）7 结算日期 也就是说，金额字段对应的数据类型是3。数据类型3又是什么呢？直接在msdn上搜索一下，发现这个页面里说的很清楚： 3对应的是4个字节的正负整数。4个字节大约可以表示从-2^31到2^31之间，大约是-2.15E9到2.15E9。难怪4.7E9显示不出来，因为变量长度溢出了啊。 为什么会出现这个问题？在用ADO读取文本文件的时候，因为文本文件中的数据格式没有被显式指定，所以ADO的文本引擎会先扫描一定的行数，然后给每列推测一个数据类型。 很显然，文中出现的问题就是因为ADO扫描完之后，指定了一个adInteger类型，但后面出现的大的数字已经超出了范围。 那么，ADO会扫描多少行呢？在网上搜了一下，在这个注册表下面有ADO文本引擎的默认设置：[Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Jet\4.0\Engines\Text] 很明显，MaxScanRows的值是25，也就是说Text引擎会扫描25行，然后根据扫描结果指定一个数据类型。 怎么解决？有两种方法。 第一种方法不太推荐，就是直接修改注册表，把MaxScanRows的值修改为足够大。如果想扫描全部内容，就把MaxScanRows的值改为0。 第二种方法更加安全一些，也就是用一个文件Schema.ini来存储文本文件的信息。 Schema.ini一定要与CSV文件在同一个目录下，他包含了下面这些信息： 文件名 文件格式 字段名 字符集 等等 详细的格式设置可以查看这个链接 在这个例子里，我们就在p.csv所在的文件夹创建Schema.ini，然后简单的指定下面的内容即可。 1234[p.csv]Format = CSVDelimitedColNameHeader = TrueMaxScanRows = 0 当然，我们也可以把创建文件的内容加入到ADO脚本里，最后完整的脚本内容就会变成： 12345678910111213141516171819202122232425262728293031323334353637Option ExplicitSub main() CreateIniFile "p.csv" LoadData "p.csv"End SubPrivate Sub LoadData(strCSVPath As String) Dim strSQL As String, strConnection As String Dim oRst As ADODB.Recordset Dim i As Integer strConnection = "Provider=Microsoft.ace.oledb.12.0;" &amp; _ "Data Source=" &amp; ThisWorkbook.Path &amp; ";" &amp; _ "Extended Properties= 'text;HDR=Yes;IMEX=1;FMT=Delimited(,)';" Set oRst = New ADODB.Recordset strSQL = "SELECT * FROM " &amp; strCSVPath oRst.Open strSQL, strConnection, adOpenStatic, adLockReadOnly Sheet1.Range("a1").CopyFromRecordset oRst oRst.Close Set oRst = NothingEnd SubPrivate Sub CreateIniFile(strCSVPath As String) Dim iFreeFile As Integer Dim StrIni As String StrIni = "[" &amp; strCSVPath &amp; "]" &amp; vbCrLf &amp; _ "Format = CSVDelimited" &amp; vbCrLf &amp; _ "ColNameHeader = True" &amp; vbCrLf &amp; _ "MaxScanRows = 0" iFreeFile = FreeFile Open ThisWorkbook.Path &amp; "\Schema.ini" For Output As #iFreeFile Print #iFreeFile, StrIni Close #iFreeFileEnd Sub 再次运行程序，发现之前的空白单元格已经有数字进来了： 总结 VBA还是要多查MSDN ADO里的Field的基本属性要熟练]]></content>
      <categories>
        <category>VBA</category>
      </categories>
      <tags>
        <tag>ADO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用scrapy爬取职位信息]]></title>
    <url>%2F2018%2F06%2F15%2F%E7%94%A8scrapy%E7%88%AC%E5%8F%96%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[​ 新开一篇，来讲解一个51JOB工作职位的爬取。目标：爬取51JOB上所有与化工相关的职位信息。 工具：scrapy框架+Python3 第一步：安装环境使用： 1virtualenv -p /usr/bin/python3 scrapy_env 来创建一个新的虚拟环境来运行scrapy cd到scrapy_env文件夹，然后执行下面语句来开启虚拟空间： 1~/scrapy_env$ source bin/activate 进入到scrapy_env的虚拟空间后，用pip3 install scrapy来安装scrapy所需要的依赖 创建Scrapy项目使用scrapy startproject来创建项目。 12345678910$ scrapy startproject 51jobError: Project names must begin with a letter and contain onlyletters, numbers and underscores~$ scrapy startproject jobsNew Scrapy project 'jobs', using template directory '/home/ubuntu/scrapy_env/lib/python3.5/site-packages/scrapy/templates/project', created in: /home/ubuntu/jobsYou can start your first spider with: cd jobs scrapy genspider example example.com 然后使用scrapy genspider来创建一个爬虫 123~/jobs$ scrapy genspider JobSpider search.51job.comCreated spider 'JobSpider' using template 'basic' in module: jobs.spiders.JobSpider 这样，项目的框架就搭好了。现在整个项目的目录文件应该是这样子的： 123456789101112131415.├── jobs│ ├── __init__.py│ ├── items.py│ ├── middlewares.py│ ├── pipelines.py│ ├── __pycache__│ │ ├── __init__.cpython-35.pyc│ │ └── settings.cpython-35.pyc│ ├── settings.py│ └── spiders│ ├── __init__.py│ ├── JobSpider.py│ └── __pycache__└── scrapy.cfg 编辑Scrapy文件Scrapy框架极大程度的减少了我们爬虫额代码编写量。对于一个简单的爬虫，我们只需要修改下面几个内容。 首次得打开网页链接：1https://search.51job.com/list/000000,000000,0000,19,9,99,%2B,2,1.html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=1&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare= items.py我们需要获取的每一条招聘内容包括了下面这些信息： 职位名 公司名 工作地点 薪资 发布时间因此，我们需要根据这些来定义一个Item，也就是一条爬取下来的信息。 1234567891011import scrapyclass JobsItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() job_title = scrapy.Field() company = scrapy.Field() job_href = scrapy.Field() location = scrapy.Field() salary = scrapy.Field() post_date = scrapy.Field() 这就好了，讲白了，我们是定义了一个名字叫JobItem的字典，然后给这个字典定义了5个键。 spiders/JobSpider.py确定了我们要获取的信息，我们就可以处理爬虫了。 爬取51job其实非常简单，我们只需要输入指定的关键字，然后点搜索，把返回的网页网址作为起始网址即可。 然后要遵循下面的这个思路： 爬某个页面 把我们所需要的字段信息装载到item里，后面我们要通过pipeline来进行处理 找到下一页的anchor标签的链接地址 如果能找到下一页的话，就递归回到第一步 在解析页面的时候，需要用到scrapy的selector对象的xpath方法。xpath相对于css选择器来说更加复杂一些，但解析效率更高。 1234567891011121314151617181920212223242526272829303132import scrapyfrom jobs.items import JobsItemclass JobspiderSpider(scrapy.Spider): name='jobspider' allowed_domains = ['search.51job.com'] start_urls = [ 'http://search.51job.com/list/000000,000000,0000,19,9,99,%2B,2,1.html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=1&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare='] def parse(self, response): next_page_url = response.xpath('//li[@class="bk"][2]/a/@href') job_list = response.xpath('//*[@id="resultList"]/div[@class="el"]') for each_job in job_list: job_info = JobsItem() job_info['job_title'] = each_job.xpath('.//p[contains(@class,"t1")]/span/a/text()') job_info['company'] = each_job.xpath('.//span[contains(@class,"t2")]/a/text()') job_info['job_href'] = each_job.xpath('.//span[contains(@class,"t2")]/a/@href') job_info['location'] = each_job.xpath('.//span[contains(@class,"t3")]/text()') job_info['salary'] = each_job.xpath('.//span[contains(@class,"t4")]/text()') job_info['post_date'] = each_job.xpath('.//span[contains(@class,"t5")]/text()') # mm-dd for k, v in job_info.items(): if v: job_info[k] = v.extract_first().strip() else: job_info[k] = 'unknown' yield job_info if next_page_url is not None: abs_url = next_page_url.extract_first().strip() yield response.follow(abs_url, callback=self.parse) pipelines.pypipelines用来处理scrapy爬取完页面然后解析出来的item。可以这么理解，pipelines把item处理完之后，会装入到数据库里去。在这里，我们要把数据装入到MYSQL数据库里，并且先不考虑去重等要求。 这需要在MySQL中先建立好DATABASE以及TABLE。 123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import pymysqlimport datetimeclass JobsPipeline(object): def open_spider(self, spider): self.database = pymysql.connect(host='localhost', port=3306, user='xxxxxx', passwd='xxxxxx', db='job_info', charset='utf8') self.cursor = self.database.cursor() self.table = 'jobs' def process_item(self, item, spider): sql_string = 'INSERT INTO &#123;&#125; (job_title, company, job_href, location, salary, post_date, update_datetime) \ VALUES("&#123;&#125;","&#123;&#125;","&#123;&#125;","&#123;&#125;","&#123;&#125;","&#123;&#125;",str_to_date("&#123;&#125;","%Y-%m-%d %H:%i:%s"));' \ .format(self.table, item['job_title'], item['company'], item['job_href'], item['location'], item['salary'], item['post_date'], datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')) try: self.cursor.execute(sql_string) self.database.commit() except: print('error') self.database.rollback() return item settings.py完成上面的处理之后，我们还需要做最后一步，修改settings.py，也就是项目设置。 最主要的是两件事情： 设置默认的请求头设置默认的请求头很简单，只需要找到，修改为下面的内容即可。 12345678910DEFAULT_REQUEST_HEADERS = &#123; 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'en-US,en;q=0.9', 'Connection':'keep-alive', 'Cookie':'your-cookie-here', 'Host':'search.51job.com', 'Referer':'http://search.51job.com/list/000000,000000,0000,19,9,99,%2B,2,2.html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=1&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=%27', 'Upgrade-Insecure-Requests':'1', 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/65.0.3325.181 Chrome/65.0.3325.181 Safari/537.36',&#125; 那上面这些内容是从哪来的呢？当然是从Chrome浏览器的Request Headers的信息拿出来的。 开启pipelines这个也很简单，把下面这句取消注释即可。 123ITEM_PIPELINES = &#123; 'jobs.pipelines.JobsPipeline': 300,&#125; 最终运行cd到项目的根目录下，注意一定要是根目录，然后执行： 1scrapy crawl jobspider 至此，一个最简单的Scrapy爬虫就写好了。后期还有很多细节要处理，比如数据去重，异常处理，数据分析等等，不过这些我们可以在后面优化，后面我们也会陆续讲解。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
</search>
