<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>计算每月的最后一个工作日</title>
      <link href="/2018/10/12/workday/"/>
      <url>/2018/10/12/workday/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>最近碰到一个需求：给定了一个日期，要求当月最后一个工作日的日期。  </p><p>谷歌了半天，发现Excel自带了一个Workday函数刚好可以解决这个问题。那Workday函数是怎么用的呢？  </p><h2 id="Workday的用法"><a href="#Workday的用法" class="headerlink" title="Workday的用法"></a>Workday的用法</h2><p>Workday的用途就是，给定一个日期，然后求这个日期指定数量工作日后（前）的日期。  </p><p>比如说，给定一个日期2007年3月8号，然后求3月8号之后第一个工作日的日期。  </p><p>具体的语法是：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Workday(start_date, days, [holidays])</span><br><span class="line">-<span class="ruby"> start_date就是给定的日期</span></span><br><span class="line"><span class="ruby">- days就是给定日期之前（之后）工作日的天数</span></span><br><span class="line"><span class="ruby">- holidays是可选参数，是一个表示假日的区域引用</span></span><br></pre></td></tr></table></figure></p><p>例如，上面的这个例子，就可以这样来写：  </p><p><img src="http://www.doublure.cn/blog/181007/AJaaJ5AAhe.png?imageslim" alt="mark"></p><p>如果需要把节假日考虑进去，那么就需要加入holiday参数。  </p><p><img src="http://www.doublure.cn/blog/181007/CE5k4JIa26.png?imageslim" alt="mark"></p><h2 id="当月最后一个工作日的思路"><a href="#当月最后一个工作日的思路" class="headerlink" title="当月最后一个工作日的思路"></a>当月最后一个工作日的思路</h2><p>整体思路框架是：  </p><ul><li>获取下个月第一天（使用Date函数）</li><li>然后用Workday,指定下个月第一天前一个工作日</li><li>剔除节假日</li></ul><p>这里需要用Date函数，配合Year, Month函数来构建下个月的第一天，然后向前数一个工作日。<br><img src="http://www.doublure.cn/blog/181007/cdC21G7J8H.png?imageslim" alt="mark"></p><p>这样，就可以实现前面的需求了！</p>]]></content>
      
      <categories>
          
          <category> Excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SIMPLEX线性回归算法</title>
      <link href="/2018/10/12/simplex-LP/"/>
      <url>/2018/10/12/simplex-LP/</url>
      <content type="html"><![CDATA[<p>​     </p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在用Solver的时候，经常会碰到碰到这么几种选项：</p><ul><li>GRG Nonlinear</li><li>Simplex LP</li><li>Evolutionary</li></ul><p>每个选项背后都隐藏了相对应的算法。平常我们一般直接运行Solver，不需要考虑算法怎么来的，但最近碰到一个问题，需要手动用Simplex算法来求解。  </p><p>Simplex算法背后是什么呢？大概查了一下，是对应的矩阵变换，然后迭代求解。具体运算暂时没有完全弄懂，只是在下面讲一下用Excel表格来求解的步骤。</p><h2 id="Simplex步骤"><a href="#Simplex步骤" class="headerlink" title="Simplex步骤"></a>Simplex步骤</h2><p>我们用一个例子来说明，如下：  </p><p><img src="http://www.doublure.cn/blog/181011/Ame5ai9idk.png?imageslim" alt="mark"></p><h3 id="加入松弛变量"><a href="#加入松弛变量" class="headerlink" title="加入松弛变量"></a>加入松弛变量</h3><p>题目给出了几个不等式，在求解之前，先要添加一些辅助参数，把不等式变成等式。  </p><p>由于限制条件里有3个方程，因此需要添加3个辅助变量，这3个辅助变量都大于等于0，我们把它分别叫做s1,s2,s3</p><p>这3个变量再加上本身就有的x1, x2,我们就得到了这样一个矩阵形式：  </p><p><img src="http://www.doublure.cn/blog/181011/lbdb67m0L3.png?imageslim" alt="mark"></p><p>要优化的目标可以表达成这样的向量形式：  </p><p><img src="http://www.doublure.cn/blog/181011/cm4eg1kCb0.png?imageslim" alt="mark"></p><blockquote><p>我们把目标向量叫做cj</p></blockquote><h3 id="构建迭代表格"><a href="#构建迭代表格" class="headerlink" title="构建迭代表格"></a>构建迭代表格</h3><p>Simplex是通过矩阵不断迭代运算得到最终优化结果的，在这里需要一个迭代表格。这个表格长的这样子：  </p><p><img src="http://www.doublure.cn/blog/181011/IK2DGck2ii.png?imageslim" alt="mark"></p><p>这里面有几个点：  </p><ul><li>basic variable最开始要设置为前面加入的松弛变量s1,s2,s3，后面，随着迭代的进行，这3个变量会逐步被替换掉</li><li>cbi对应的是每个变量在cj中对应的系数。例如，s1,s2,s3在cj中都是0，因此cbi这里都是0</li><li>zj是cbi这个向量和每一个 variable所对应的列，作矩阵相乘运算，得到的结果。下面这个图显示的是x1变量对应的列和cbi相乘的结果。<br><img src="http://www.doublure.cn/blog/181011/f960KI0GkB.png?imageslim" alt="mark"></li><li>最下面一行是cj-zj,也就是把两个矩阵相减。对于一个求最大值的问题，迭代停止的条件就是cj-zj所得到的矩阵每一个元素都小于等于0。</li></ul><h3 id="进行迭代"><a href="#进行迭代" class="headerlink" title="进行迭代"></a>进行迭代</h3><p>上面一张图我们看到，cj-zj这个矩阵，并不符合停止迭代的条件，于是要继续进行下一次迭代。  </p><p>下一次迭代需要更换basic variable,换哪个呢？  </p><ul><li><p>我们查找上一次迭代中，cj-zj中最大的元素，也就是3：<br><img src="http://www.doublure.cn/blog/181011/5mBA2l78EH.png?imageslim" alt="mark"></p></li><li><p>把3对应的这一列作标记</p></li><li><p>然后在上图表格中的ratio列，计算solution除以3这一列对应的值,我们求最小值，在这里也就是3.5</p></li><li>把最小值对应的一行作标记<br><img src="http://www.doublure.cn/blog/181011/1lffG2bCjb.png?imageslim" alt="mark"></li><li>我们看到，标记的列，对应的是x2变量，标记的行，对应的是s2变量。</li><li>于是，我们在basic variables中把s2去掉，x2加上,并且把x2在cj中对应的系数更新到cbi中，变成下面这个表格<br><img src="http://www.doublure.cn/blog/181011/Fl1lllcF58.png?imageslim" alt="mark"></li><li>然后计算表格中各个变量对应的数值。对于新加入的x2变量，直接用原有数值，除以上一步中标记的行和列的交叉值（在这里是2）即可。<br><img src="http://www.doublure.cn/blog/181011/4Ck9bL2cjB.png?imageslim" alt="mark"></li><li>对于上一次迭代就存在的变量(在这里是s1和s3),他们的值要用这样一个公式：<br>这里直接用图来表示吧：<br><img src="http://www.doublure.cn/blog/181012/H5Eik8eebL.png?imageslim" alt="mark"></li><li>然后按照上面一次迭代中所讲的，计算cj-zj<br><img src="http://www.doublure.cn/blog/181012/deA5d29FDk.png?imageslim" alt="mark"><br>这里我们发现cj-zj中依旧有一个值大于0，对应x1变量，s3变量对应行的ratio最小，所以下一步就要把s3替换成s1.</li></ul><h3 id="再进行一次迭代"><a href="#再进行一次迭代" class="headerlink" title="再进行一次迭代"></a>再进行一次迭代</h3><p>按照上面的步骤，重复一次迭代，得到下面结果：  </p><p><img src="http://www.doublure.cn/blog/181012/mJCf3Bi5GB.png?imageslim" alt="mark"></p><p>这次，cj-zj这个矩阵符合要求了，迭代停止。  </p><p>答案在哪里呢？  </p><p>迭代停止的时候，basic variables所对应的solution的值，就是这些变量的最优解。<br>basic variables里面没有的变量，也就是其他变量，都为0。  </p><p>于是，有了变量的值，再加上变量的系数（cj矩阵），我们就可以计算出最终的优化值了。  </p><p><img src="http://www.doublure.cn/blog/181012/11iA5IdE55.png?imageslim" alt="mark"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是一个照猫画虎的过程，原理后面需要做详细探讨。</p>]]></content>
      
      <categories>
          
          <category> Excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单一指数模型的Excel实现</title>
      <link href="/2018/08/27/sim-with-excel/"/>
      <url>/2018/08/27/sim-with-excel/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><ul><li>单一指数模型SIM  </li></ul><h2 id="Excel的实现"><a href="#Excel的实现" class="headerlink" title="Excel的实现"></a>Excel的实现</h2><p>我们说过，单一指数模型的公式是这样子的：<br><img src="http://www.doublure.cn/blog/180806/ElGlhc2j9i.png?imageslim" alt="mark"></p><p>如果大家做过回归分析的话，就可以看出来，这个公式实际上就是最小二乘法进行的回归曲线。  </p><p>于是，我们可以利用Excel的LINEST函数，来实现SIM法求协方差矩阵。  </p><h3 id="求相关参数"><a href="#求相关参数" class="headerlink" title="求相关参数"></a>求相关参数</h3><p>我们在前面的公式知道，如果是要求协方差矩阵，只需要知道这么几项就可以：  </p><ul><li>每一项资产的β和对应残差的标准差σ</li><li>市场组合的方差</li></ul><p>求资产的β和σ，可以使用LINEST函数，选定5*2的区域，进行线性回归：  </p><p><img src="http://www.doublure.cn/blog/180807/dcceaGHjdK.png?imageslim" alt="mark"></p><ul><li>注意上图中的数据已经经过预先处理，定义好了名称区域</li><li>使用数组公式进行LINEST求解</li></ul><p>得到的一个5*2的矩阵，每一个矩阵元素对应的是什么呢？<br><img src="http://www.doublure.cn/blog/180807/2meb6hCI7k.png?imageslim" alt="mark"></p><p>我们可以看到，5*2矩阵中(1,1)位置就是β，(3,2)号位置是残差的标准差σ。  </p><p>上面只是求了600825这个资产的β和残差的σ，如果想对每一个资产进行求解，需要配合使用INDEX函数。  </p><p><img src="http://www.doublure.cn/blog/180807/l0e3Hk3L1d.png?imageslim" alt="mark"></p><p>最后使用VAR函数，求出市场的方差。  </p><h3 id="求协方差矩阵"><a href="#求协方差矩阵" class="headerlink" title="求协方差矩阵"></a>求协方差矩阵</h3><p>有了上面这些数据，我们就可以计算协方差矩阵了。</p><p>在对角线位置，使用这个公式：</p><p><img src="http://www.doublure.cn/blog/180806/BbcGd6AHC2.png?imageslim" alt="mark">  </p><p>在其他位置，使用下面这个公式，并结合HLookup函数：</p><p><img src="http://www.doublure.cn/blog/180806/3LaBAB5Ec5.png?imageslim" alt="mark"></p><p>最后得到协方差矩阵为：</p><p><img src="http://www.doublure.cn/blog/180807/6649G0L7h6.png?imageslim" alt="mark"></p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
            <tag> 单一指数模型 </tag>
            
            <tag> 金融建模 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单一指数模型</title>
      <link href="/2018/08/27/single-index-model/"/>
      <url>/2018/08/27/single-index-model/</url>
      <content type="html"><![CDATA[<p>​<a id="more"></a></p><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><ul><li>系统风险β的引入</li><li>CAPM模型 </li></ul><h2 id="CAPM模型的局限"><a href="#CAPM模型的局限" class="headerlink" title="CAPM模型的局限"></a>CAPM模型的局限</h2><p>前面我们在讲CAPM模型时，说到其公式反应了主要是系统风险，资产的超额收益完全是跟着市场走。  </p><p>但是，我们知道市场里的不确定性简直太多了，仅仅靠一个β来说明未免有些牵强。最好还要有非系统性风险(firm specific)的体现。<br>另外，传统的计算资产组合收益的方法，需要计算资产两两组合的协方差。当资产数量上升后，需要计算的资产组合数量急剧上升，N个资产构成的组合P，要计算P的均值和方差需要计算<code>N(N-1)/2</code>次，也就是说，这种方法的计算复杂度为O(n2)。  </p><p>单一指数模型，改善了上面两点。针对第一点，单一指数模型引入了非系统性风险，以及不受市场波动影响的部分。针对第二点，单一指数模型通过把市场指数和每项资产关联起来，相当于给每项资产之间架起了一个枢纽，这样可以大大减少了计算协方差矩阵的计算量。  </p><h2 id="单一指数模型-Single-Index-Model"><a href="#单一指数模型-Single-Index-Model" class="headerlink" title="单一指数模型(Single Index Model)"></a>单一指数模型(Single Index Model)</h2><h3 id="单一资产方差的计算"><a href="#单一资产方差的计算" class="headerlink" title="单一资产方差的计算"></a>单一资产方差的计算</h3><p>这个模型中，资产的收益可以表达成下面的形式：<br><img src="http://www.doublure.cn/blog/180806/dH9Lg6kkA9.png?imageslim" alt="mark"></p><p>如果用R表示超额收益，那么可以简写为：  </p><p><img src="http://www.doublure.cn/blog/180806/ElGlhc2j9i.png?imageslim" alt="mark"></p><p>其中，</p><ul><li>α表示资产独立于市场波动的收益</li><li>β表示资产的系统性风险</li><li>e表示资产特有的风险  </li></ul><p>当然，每个模型的提出都需要假设：  </p><ul><li>系统性风险和非系统风险完全不相关，即协方差为0  </li><li>不同资产的e相互完全不相关</li></ul><p>在这种情况下，我们可以把一项资产看做是由α，Rm，以及e组成的资产组合。资产的方差就可以这样计算：  </p><p><img src="http://www.doublure.cn/blog/180806/BbcGd6AHC2.png?imageslim" alt="mark"></p><p>这个公式就能看得出来，<code>总风险=系统风险+公司特定风险</code>  </p><h3 id="协方差计算"><a href="#协方差计算" class="headerlink" title="协方差计算"></a>协方差计算</h3><p>如果要计算协方差，需要通过Rm这个中介来换算。  </p><p><img src="http://www.doublure.cn/blog/180806/0lcgLBK2el.png?imageslim" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r_&#123;i,m&#125;= \frac&#123;\sigma _&#123;i,m&#125;&#125;&#123;\sigma_&#123;i&#125;\sigma_&#123;m&#125;&#125; </span><br><span class="line"></span><br><span class="line">r_&#123;j,m&#125;= \frac&#123;\sigma _&#123;j,m&#125;&#125;&#123;\sigma_&#123;j&#125;\sigma_&#123;m&#125;&#125; </span><br><span class="line"></span><br><span class="line">\sigma _&#123;i,m&#125;=\beta_&#123;i&#125; \sigma _&#123;m&#125;^&#123;2&#125;  </span><br><span class="line"></span><br><span class="line">\sigma _&#123;j,m&#125;=\beta_&#123;j&#125; \sigma _&#123;m&#125;^&#123;2&#125;</span><br><span class="line"></span><br><span class="line">r_&#123;i,j&#125;= \frac&#123;\sigma _&#123;i,j&#125;&#125;&#123;\sigma_&#123;i&#125;\sigma_&#123;j&#125;&#125;</span><br></pre></td></tr></table></figure><p>综合上面的公式，可以得到：  </p><p><img src="http://www.doublure.cn/blog/180806/3LaBAB5Ec5.png?imageslim" alt="mark"></p><p>于是，我们看到，知道了资产的β系数之后，再加上市场的方差，就可以很容易求出资产之间的协方差了。  </p><h2 id="资产组合的收益与风险"><a href="#资产组合的收益与风险" class="headerlink" title="资产组合的收益与风险"></a>资产组合的收益与风险</h2><p>如果一个资产组合P里有N项资产，那么P的加权超额收益期望为：  </p><p><img src="http://www.doublure.cn/blog/180806/mcE43Lc9LJ.png?imageslim" alt="mark"></p><p>于是，我们可以得到组合P的β值为：  </p><p><img src="http://www.doublure.cn/blog/180807/jl551k96fJ.png?imageslim" alt="mark"></p><p>如果n比较大，e的部分可以忽略不计，因此可以得到：</p><p><img src="http://www.doublure.cn/blog/180806/jjG232475A.png?imageslim" alt="mark">  </p><p>对于组合P的方差，可以这样计算：  </p><p><img src="http://www.doublure.cn/blog/180807/I9a8mJi25f.png?imageslim" alt="mark"></p><p>其中：  </p><p><img src="http://www.doublure.cn/blog/180807/8mkI0deEhD.png?imageslim" alt="mark"></p><p>当然，上面这个公式的得出基于不同公司的非系统风险相对独立。<br>我们可以看到，当n趋向于多时，非系统风险的方差贡献几乎为0，因此非系统风险得到了分散。  </p><p>再极端一点，我们买入全部的市场组合，那么β就是1，P的方差就等于市场M的标准差。  </p><p>有了单一指数模型之后，根据上面的公式，如果再要计算一个组合P的均值和方差，那么我们只需要：  </p><ul><li>计算n次α</li><li>计算n次β</li><li>计算n次e的方差<br>然后简单的做一个加权或者加法就可以。这样计算复杂度就下降到了O(n)。比开头的方法整整少了一个数量级。</li></ul><h2 id="单一指数模型的局限"><a href="#单一指数模型的局限" class="headerlink" title="单一指数模型的局限"></a>单一指数模型的局限</h2><ul><li>SIM模型的假设有时未必成立，因此计算精度会受到影响。<br>比如，其假设每个公司的ei相互独立，但实际上同一个行业内的公司ei很有可能是有正相关关系的。  </li></ul><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://wenku.baidu.com/view/b18142bf336c1eb91b375df5.html?from=search" target="_blank" rel="noopener">https://wenku.baidu.com/view/b18142bf336c1eb91b375df5.html?from=search</a><br><a href="https://wenku.baidu.com/view/46e7231b9ec3d5bbfc0a74c5.html?from=search" target="_blank" rel="noopener">https://wenku.baidu.com/view/46e7231b9ec3d5bbfc0a74c5.html?from=search</a></p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单一模型 </tag>
            
            <tag> 协方差 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资本结构概论</title>
      <link href="/2018/08/27/capital-structure/"/>
      <url>/2018/08/27/capital-structure/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><h2 id="完美市场下的资本结构"><a href="#完美市场下的资本结构" class="headerlink" title="完美市场下的资本结构"></a>完美市场下的资本结构</h2><p>什么是perfect markt ?</p><ul><li>没有税(公司和个人税)</li><li>没有交易成本（类似的破产成本以及其他）</li><li>没有信息不对称</li></ul><p>除了上面perfect market的假设以外，还有两点重要的假设：  </p><ul><li>公司的价值，与资本结构无关，同理，公司的股价，也无资本结构无关</li><li>借贷会导致权益成本提高</li><li>最终的加权成本不变</li></ul><p>这上面就是MM理论了，怎么来解释呢？ </p><p>大概的意思就是，我要投资100块钱出去，不管我借20，还是借80块，还是完全自己出资100块，我都会投资。因此资本结构并不能决定公司的价值。</p><h3 id="公司价值与资本结构无关"><a href="#公司价值与资本结构无关" class="headerlink" title="公司价值与资本结构无关"></a>公司价值与资本结构无关</h3><p>这个理论认为，公司的价值，只和公司能够创造多少收入有关。<br>公司的价值就等于：  </p><p>因此，不论资本结构如何，公司整体价值都是不变的。</p><p><img src="http://www.doublure.cn/blog/180826/H28f51l4KG.png?imageslim" alt="mark"></p><ul><li>其中，Vu是指无杠杆下公司的价值</li><li>Ksu是指无杠杆的权益成本</li><li>EBIT就是普通的息税前利润</li></ul><h3 id="借贷会导致权益成本提高"><a href="#借贷会导致权益成本提高" class="headerlink" title="借贷会导致权益成本提高"></a>借贷会导致权益成本提高</h3><p>如果公司从自有资本转向借贷，那么公司股东会认为公司经营的风险升高，于是相应的权益成本的期望也会提高。</p><p>那么权益成本会提高多少呢？  </p><p><img src="http://www.doublure.cn/blog/180826/1Imjg7gDDa.png?imageslim" alt="mark"></p><ul><li>Vsl是权益价值</li><li>Ksl是杠杆后的权益成本</li><li>Kd是负债成本</li><li>D是负债</li></ul><p>又因为 EBIT/Ksu = S+D，并且公司价值不随资本结构的变化，因此：  </p><p>EBIT=（S+D)*Ksu</p><p>再带入上面的公式中，就可以得到：  </p><p><img src="http://www.doublure.cn/blog/180826/8g8bJdDeH3.png?imageslim" alt="mark"></p><p>如果用这个计算加权成本wacc，可以这样来计算：  </p><p><img src="http://www.doublure.cn/blog/180826/7BGLCACCB7.png?imageslim" alt="mark"></p><p>因此，<strong>加权平均成本不变</strong>，就等于无负债的权益成本</p><p>上面是不存在任何税的情况下，得到的结论。那么，如果有公司税的存在会是怎么样呢？ </p><h2 id="非完美市场下的资本结构"><a href="#非完美市场下的资本结构" class="headerlink" title="非完美市场下的资本结构"></a>非完美市场下的资本结构</h2><p>我们在这里先考虑只有公司税Tc的情况。  </p><p>在有公司税的情况下，没有贷款和有贷款公司的价值表示如下：</p><p><img src="http://www.doublure.cn/blog/180827/HkK7916b9c.png?imageslim" alt="mark"></p><p>可以看出，有借款的情况下，除了正常的无杠杆的现金流部分以外，还产生了与负债相关的一个现金流。</p><p>正常现金流折现，得到的价值就是Vu.<br>而负债相关的现金流部分，需要用kd来折现，得到的结果就是DTc.<br>而根据估值的打包资产相加理论： VL = Vu + DTc  </p><p>也就是说，有杠杆的公司价值等于无杠杆的价值加上税盾。  </p><p>举个例子，上面这个可以这么理解：公司的价值等于其相对于债权人和股东合起来的价值。</p><ul><li>如果不借贷，其相对于股东的价值就是EBIT(1-Tc)。</li><li>如果完全借贷，其相对于债权人就相当于是EBIT，明显有价值上的提升。  </li></ul><blockquote><p>个人感觉税盾更多是从经济层面上来考虑，不赚就是损失，少付就是赚钱，不知道理解的对不对</p></blockquote><p>在有公司税的情况下，MM定理的第二个结论，也就是有杠杆的权益成本可以用如下方式进行推导： </p><p><img src="http://www.doublure.cn/blog/180827/KLJ4l87Hmb.png?imageslim" alt="mark"></p><p>可以看出，如果Tc=0，那么这个公式就和前面无税的公式一样了。  </p><p>有了Ksl之后，WACC也可以计算出来了：</p><p><img src="http://www.doublure.cn/blog/180827/9jcHB825jK.jpg?imageslim" alt="mark"></p><p>从结果我们可以看出来，一般Kd是小于Ksu的，因此，在只考虑公司税的情况下，举债可以降低加权资本成本。 </p><p>上面基本上就是MM模型的两个定论了。 </p><p>后来，米勒又在这个基础上，针对有公司税和个人所得税的基础上，又进行了论证，称之为米勒模型  </p><h2 id="考虑个人所得税"><a href="#考虑个人所得税" class="headerlink" title="考虑个人所得税"></a>考虑个人所得税</h2><p>先做几个名词解释：  </p><p>Tc: 公司税<br>Td: 个人所得税税率<br>Te: 权益收益税率</p><p>在这个模型里，就直接上公式推导了：  </p><p><img src="http://www.doublure.cn/blog/180827/7gkGmBdB7k.jpg?imageslim" alt="mark"></p><p>也就是说，当考虑个人所得税和权益所得税时，举债不一定能提高公司价值。这得看1-Td和(1-Tc)(1-Te)的值哪个大。 </p><p>然后根据这个公式，可以推出来：  </p><p><img src="http://www.doublure.cn/blog/180827/k8m92lgKfG.jpg?imageslim" alt="mark"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Modigliani%E2%80%93Miller_theorem#Proposition_II" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Modigliani%E2%80%93Miller_theorem#Proposition_II</a></p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资本结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DCF中的NOPAT</title>
      <link href="/2018/08/27/nopat/"/>
      <url>/2018/08/27/nopat/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>在使用DCF的时候，初次使用NOPAT作为基础来计算FCF，总是觉得有些懵。为什么要直接把EBIT*(1-Tc)呢？应该是先扣利息，再扣税啊。  </p><p>这里就来研究一下。  </p><p>我们说，一个企业的FCF就是企业能够用于经营的，自由支配的现金流。  </p><p>那么，追根溯源，企业的FCF都可以从哪里来呢？</p><h2 id="计算FCF的基础"><a href="#计算FCF的基础" class="headerlink" title="计算FCF的基础"></a>计算FCF的基础</h2><p>首先当然是净利润：Net Profit<br>如果要非得深究的话，其实利润表里的净利润，不一定代表就是现金。不过这点可以通过后面进行调整。  </p><p>然后要把付出利息加进来。因为利息虽然最终付给债权人了，但他还是属于公司可以自由处理的现金的一部分。 </p><p>那么要加上多少利息呢？如果把支付的利息定义为I，那么由于利息的税盾作用，税盾的值为I*Tc,那么实际支付的利息就是：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">I</span><span class="params">(<span class="number">1</span>-Tc)</span></span></span><br></pre></td></tr></table></figure><p>所以，<code>Net Profit + I*(1-Tc)</code>就成为我们计算FCF的基础。</p><p>后面需要再加上折旧，减去NOWC的变化，减去CAPEX，这些就不做说明了。  </p><h2 id="NOPAT的得来"><a href="#NOPAT的得来" class="headerlink" title="NOPAT的得来"></a>NOPAT的得来</h2><p>我们知道：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Net Profit = (<span class="name">EBIT-I</span>)*(<span class="number">1</span>-Tc) = EBIT*(<span class="number">1</span>-Tc) - I(<span class="number">1</span>-Tc)</span><br></pre></td></tr></table></figure></p><p>把这个等式移项，就能得到：  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Net Profit + I(<span class="number">1</span>-Tc)= (<span class="name">EBIT-I</span>)*(<span class="number">1</span>-Tc)</span><br></pre></td></tr></table></figure><p>巧合的是，<code>Net Profit + I(1-Tc)</code>正好是计算FCF的基础。<br>于是，把<code>(EBIT-I)*(1-Tc)</code>定义为NOPAT，就可以替代<code>Net Profit + I(1-Tc)</code>来计算FCF。  </p><p>所以，在讲DCF的时候，有些书是先计算NOPAT，有些书对NOPAT只字未提，只从净利润出发。其实这两种方法是一样的，只是表现形式不同而已。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 估值 </tag>
            
            <tag> DCF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>债券定价原理</title>
      <link href="/2018/08/27/bonds-pricing/"/>
      <url>/2018/08/27/bonds-pricing/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><p>前面介绍了：  </p><ul><li>普通债券的价格计算原理</li><li>使用Excel计算债券价格以及收益率  </li></ul><p>根据债券价格的计算公式，我们可以得到债券定价的5个原理，也被称作是马尔基尔原理。  </p><h2 id="债券的定价原理"><a href="#债券的定价原理" class="headerlink" title="债券的定价原理"></a>债券的定价原理</h2><p>为了研究债券的定价原理，我们首先根据债券的YTM(Yield to maturity)以及价格来做一个Excel的数据表：  </p><p><img src="http://www.doublure.cn/blog/180819/96d5GIdb56.png?imageslim" alt="mark"></p><blockquote><p>数据表(Data Table)是Excel中用于分析变量敏感度的一个很有效的工具  </p></blockquote><p>数据表里有两个变量：一个是YTM，一个是债券的年限。<br>数据表的YTM作为横坐标，不同年限，对应YTM的价格作为纵坐标，做散点图，可以得到上图右边的一个图。 </p><p><img src="http://www.doublure.cn/blog/180819/acJC0fK8ge.png?imageslim" alt="mark"></p><p>观察这个图，我们就可以来证明债券定价的原理。  </p><h3 id="债券价格与利率呈反向变化"><a href="#债券价格与利率呈反向变化" class="headerlink" title="债券价格与利率呈反向变化"></a>债券价格与利率呈反向变化</h3><p>首先，我们很容易观察到YTM下降，债券价格将上升。这个也就是第一条法则：<strong>债券价格与利率呈反向变化</strong></p><h3 id="对于一定收益率的变化，长期债券的价格变化大于短期债券的价格变化"><a href="#对于一定收益率的变化，长期债券的价格变化大于短期债券的价格变化" class="headerlink" title="对于一定收益率的变化，长期债券的价格变化大于短期债券的价格变化"></a>对于一定收益率的变化，长期债券的价格变化大于短期债券的价格变化</h3><p>这点也可以通过图来直接看出来。  </p><p>无论债券期限多长，在YTM在0.08时，债券的价格都等于1000，即面值。  </p><p>如果YTM从0.08降到0.01，我们可以看到，所有债券的价格都在升高，但50年债券的价格增长的最大。这个也和定理吻合。  </p><h3 id="随着债券年限的增长，债券价格对收益率的变化的敏感性将增加，但增加的速度不断下降"><a href="#随着债券年限的增长，债券价格对收益率的变化的敏感性将增加，但增加的速度不断下降" class="headerlink" title="随着债券年限的增长，债券价格对收益率的变化的敏感性将增加，但增加的速度不断下降"></a>随着债券年限的增长，债券价格对收益率的变化的敏感性将增加，但增加的速度不断下降</h3><p>这句话的前半句其实已经证明过了，年限越长的债券，对收益率的敏感度越高。  </p><p>那么后半句怎么理解呢？  </p><p>简单点从图上来观察的话，发现随着年限的增加，在1%点的截距越来越密，也就是说，债券价格增长的速度在下降  </p><h3 id="债券价格的不对称性"><a href="#债券价格的不对称性" class="headerlink" title="债券价格的不对称性"></a>债券价格的不对称性</h3><p>这个从图上也不难看出。YTM从8%到1%，债券价格上升的金额明显要大于利率从8%上升到15%，债券价格下降的金额。  </p><h3 id="高票面利率债券对YTM变化的敏感性大于低票面利率债券"><a href="#高票面利率债券对YTM变化的敏感性大于低票面利率债券" class="headerlink" title="高票面利率债券对YTM变化的敏感性大于低票面利率债券"></a>高票面利率债券对YTM变化的敏感性大于低票面利率债券</h3><p>为了证明这点的话，上面的图就不适合了，需要生成一组新的数据： </p><p><img src="http://www.doublure.cn/blog/180819/ECDFhfEim4.png?imageslim" alt="mark"></p><p>从图中标橙色的可以看出来，的确票面利率越低，对YTM变化的敏感性越大。  </p><p>如果把上面的数据做散点图，似乎图与上面的结论相悖：</p><p><img src="http://www.doublure.cn/blog/180819/0ajhf2IGLI.png?imageslim" alt="mark"></p><p>图的横坐标是YTM，纵坐标是不同票面利率对应的价格。<br>明显可以看出，票面利率越高，相同YTM的变化所对应的债券价格的变化越大。  </p><p>但是，我们在这里讨论的敏感度是变化百分比。因此，虽然高票面利率债券的变化的绝对值大，但他的百分比还是要小，这点要注意。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这5条定理从数学根源上，是对价格-YTM进行求一阶导数和二阶导数的出来的，在这里，我们先要知道结论，证明过程后面再研究。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 估值 </tag>
            
            <tag> 债券 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>债券估值</title>
      <link href="/2018/08/27/bonds/"/>
      <url>/2018/08/27/bonds/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><h2 id="债券的特点"><a href="#债券的特点" class="headerlink" title="债券的特点"></a>债券的特点</h2><p>前面讲的一直是普通股以及优先股的估值。在可供我们投资的产品中，还有一种，就是风险相对低的债券。风险低到什么程度呢？在很多情况下大家都会以美国的国债作为无风险收益率。基本上来看，债券有这个几个特点：  </p><ul><li>发行人定期支付利息</li><li>债券到期偿还本金</li><li>发行价格可能会有溢价或者折扣</li><li>公司破产清算时，债券优先于股票得到赔偿  </li></ul><h2 id="债券价格的计算"><a href="#债券价格的计算" class="headerlink" title="债券价格的计算"></a>债券价格的计算</h2><p>根据上面的债券特点，我们就可以根据资本的现值和终值理论，来对债券的价格和价值进行计算。  </p><h3 id="付息日债券价格的计算"><a href="#付息日债券价格的计算" class="headerlink" title="付息日债券价格的计算"></a>付息日债券价格的计算</h3><p>为什么这里要分付息日和非付息日？因为在付息日那天，剩余的期数刚好为整数，正巧可以使用Excel自带的PV函数。  </p><p>我们先看一个债券的时间线：  </p><p><img src="http://www.doublure.cn/blog/180818/BLAe1jDgKK.png?imageslim" alt="mark"></p><p>根据我们前面在PV和FV那一课讲的内容，债券的PV可以用这个公式来计算：  </p><p><img src="http://www.doublure.cn/blog/180818/1m48CaAHG7.png?imageslim" alt="mark"></p><p>这里：  </p><ul><li>PMT就是债券每次发的利息</li><li>kb实际上是我们对债券的要求报酬率</li><li>FV是债券的面值（如果我们一直持有到期的话）</li><li>N就是还剩下的期数</li></ul><p>于是，我们就可以直接使用Excel自带的PV函数来计算了。  </p><p>下面这个使用Excel对一个为期20年，每年付息2次，票面年化利率为8%，而个人要求报酬率为9%，面值为1000元的债券进行了计算，用PV函数求出了发行之初的价值：</p><p><img src="http://www.doublure.cn/blog/180818/AE70D8KgdI.png?imageslim" alt="mark"></p><h3 id="非付息日债券价格的计算"><a href="#非付息日债券价格的计算" class="headerlink" title="非付息日债券价格的计算"></a>非付息日债券价格的计算</h3><p>如果是非付息日的话，就不可以使用PV函数来计算了。这个时候应该采取这种思路：  </p><ul><li>计算出离当日最近的上一个付息日</li><li>然后利用上一个付息日的现值，计算出当天的终值</li><li>然后用当天的终值减去从上一个付息日到当天所应获得的利息</li></ul><p>看起来相当繁琐，我们试着用Excel来实现一下。  </p><p><img src="http://www.doublure.cn/blog/180818/mKF0f8l6I0.png?imageslim" alt="mark"></p><p>还是上面那个例子，付息一共40期，每期半年，那么我要计算从债券发售开始，过去两个月（也就是还有39 2/3期）的时候，债券的价格。  </p><ul><li>首先，我们应该计算离到期还有40期的价格（因为39 2/3最近的付息日就是40期的时候）。前面已经计算出来等于907.99</li><li>然后，从40期的价格推算到39 2/3的终值<br><img src="http://www.doublure.cn/blog/180818/E81D1Lfjkc.png?imageslim" alt="mark"><br>计算出来等于921.41</li><li>上面计算出来的921.41包括了2个月的利息，需要扣除掉，才能得到债券的交易价格。2个月的利息就是1000*0.08/2/3=13.33</li><li>然后用921.41减去13.33即可得到当日的价格<br><img src="http://www.doublure.cn/blog/180818/kHbD0CglI9.png?imageslim" alt="mark"></li></ul><h3 id="使用Excel进行债券价格计算"><a href="#使用Excel进行债券价格计算" class="headerlink" title="使用Excel进行债券价格计算"></a>使用Excel进行债券价格计算</h3><p>上面这种方法，虽然逻辑很清晰，但过程需要好几步，实现起来蛮复杂。Excel里自带了一个PRICE函数，可以帮助我们实现。  </p><p><img src="http://www.doublure.cn/blog/180818/3m65c7g6GA.png?imageslim" alt="mark"></p><p>在这里直接上图了。PRICE函数包含几个参数：  </p><ul><li>Settlement指的是买入债券的日期</li><li>Maturity指的是债券到期的日期</li><li>Rate指的是票面利息</li><li>Yield指的是要求报酬率</li><li>Redemption指的是到期时，回购价格与票面价格的比例。注意这个是一个百分数</li><li>Frequency指的是债券每年付息的次数，只有1,2,4三种选择</li><li>Basis指的是对天数的假设。默认为0，也就是一个月有30天，一年有360天。  </li></ul><p>最终得到的一个数值，是与票面价格相比的百分数。这里可以看到是90.80，再乘上票面价格就是债券的价格。  </p><h2 id="债券收益"><a href="#债券收益" class="headerlink" title="债券收益"></a>债券收益</h2><p>债券收益是投资债券时一个很重要的指标，也是后面研究收益-价格曲线的一个基础。在这里我们主要研究一下两种收益：</p><h3 id="到期收益率"><a href="#到期收益率" class="headerlink" title="到期收益率"></a>到期收益率</h3><p>也就是债券持有到期的年化符合报酬率。  </p><p>其实，在前面学习PV和FV的时候，我们知道相对应的还有RATE函数，用于求收益率。对于债券也是一样，不过债券的计算使用的是YIELD函数。  </p><p><img src="http://www.doublure.cn/blog/180818/BClDFlDHIC.png?imageslim" alt="mark"></p><p>里面参数的定义和PRICE函数差不多，唯一要注意的是，PR是一个相对于面值的百分比。  </p><p>如果再回想一下资本预算时计算IRR时遇到的问题，这种计算到期收益率也会有类似的问题：  </p><ul><li>默认收到的股息会按照要求报酬率复投，没有考虑Reinvestment risk<br>另外，到期收益率默认持有到期，但没有考虑不到期就出售的情况。  </li></ul><h3 id="赎回收益率"><a href="#赎回收益率" class="headerlink" title="赎回收益率"></a>赎回收益率</h3><p>与到期收益率的计算方法类似，赎回收益率的计算同样适用YIELD函数，只是将PR修改为债券被赎回时的价格百分比(一般都大于100)即可。</p><p><img src="http://www.doublure.cn/blog/180818/30L4Dd1L20.png?imageslim" alt="mark"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>债券价格的计算，无论采用哪种方式，都是基于PV和FV理论</li><li>PRICE和YIELD函数可以轻松计算债券的价格和收益率</li></ul>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 估值 </tag>
            
            <tag> 债券 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DCF法估值</title>
      <link href="/2018/08/27/dcf/"/>
      <url>/2018/08/27/dcf/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><ul><li>使用DDM法进行估值</li></ul><h2 id="DCF法"><a href="#DCF法" class="headerlink" title="DCF法"></a>DCF法</h2><p>前面说的DDM法，包括了3个模型，基本上是假定我们会永久持有股票，股票的收益都来自股利。  </p><p>但是，在很多情况下靠股利来获利并不是那么靠谱的一个方法。所以我们得想个别的方法来估值。  </p><p>一个最核心的理论基础是：企业(这里指的是整个企业，不仅仅包括股票所体现的价值)的价值，就等于未来现金流的折现，加上非营业资产的价值。于是，我们只要能弄清楚前面所说的几个问题：   </p><ul><li>现金流有多少</li><li>现金流在什么时候</li><li>资本成本有多少</li><li>非营业资产有多少</li></ul><p>关于资本成本，实际上我们前面在DDM法里已经研究过了。折现的逻辑，DDM和DCF也差不多。于是，我们接下来首先要研究现金流的数量问题  </p><h3 id="营业资产的FCF折现法"><a href="#营业资产的FCF折现法" class="headerlink" title="营业资产的FCF折现法"></a>营业资产的FCF折现法</h3><p>我们在折现模型中要研究的现金流，是指企业可以自由支配使用的现金流，也叫自由现金流(Free Cash Flow)。  </p><p>如何计算自由现金流呢？  </p><ol><li><p>先计算出NOPAT(Net Operating Profit After Tax)，也就是EBIT扣税后的部分。<br> 你可能会问了，为什么不先扣除利息啊？这个道理和资本成本中不考虑利息的道理类似，因为我们在折旧系数里已经考虑了利息，也就是资本成本的影响。  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. 然后加上非现金费用。为什么要机上呢？因为NOPAT是从利润表里的出来的，在计算的过程中扣除了固定资产成本等非现金费用，并没有付出现金。因此，这里需要再加上去。  </span><br><span class="line">    ```营业现金流=NOPAT+非现金费用</span><br></pre></td></tr></table></figure></li><li><p>有了现金流之后，为了维持企业的正常运转，需要进行投资。投资性支出又可以分成两类：用于固定资产的投资，以及用于流动性较强的资产的投资，体现为净营运资本的变化。这两个合起来，就是：<br> <img src="http://www.doublure.cn/blog/180811/kkgCFCHgd1.png?imageslim" alt="mark"></p></li><li><p>于是，总的自由现金流就等于：<br> <img src="http://www.doublure.cn/blog/180811/F9Hk4ELC8F.png?imageslim" alt="mark"></p></li></ol><p>于是，根据现金流折现出来的公司价值就可以计算为：  </p><p><img src="http://www.doublure.cn/blog/180811/h0laaA6ka0.png?imageslim" alt="mark"></p><h3 id="非营业性资产的影响"><a href="#非营业性资产的影响" class="headerlink" title="非营业性资产的影响"></a>非营业性资产的影响</h3><p>上面计算的其实都是营业资产折现而得到的公司价值。当然，公司还有非营业资产。于是，公司整个价值等于营业和非营业资产的相加。  </p><p><img src="http://www.doublure.cn/blog/180811/1Dekdad39D.png?imageslim" alt="mark"></p><p>另外一种思路是，公司的价值等于公司债券，加上普通股，再加上优先股的价值的总和。因此，公司整个价值还可以这样计算：  </p><p><img src="http://www.doublure.cn/blog/180811/J6aaJefdkC.png?imageslim" alt="mark"></p><p>于是，普通股所有的价值就等于：  </p><p><img src="http://www.doublure.cn/blog/180811/ecFeh0E86I.png?imageslim" alt="mark"></p><p>然后再确定一下发行的普通股的数量，就可以得到普通股的内在价值了。 </p><p>实际上，上面这个公式默认的是自由现金流永续增长。当然，类似与DDM的二段和三段模型，DCF法也可以采用类似的方法进行营业资产的估值。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>从这个可以看出，货币的时间价值这个知识点很重要</li></ul>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 估值 </tag>
            
            <tag> 现金流折现 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDM估值</title>
      <link href="/2018/08/27/ddm/"/>
      <url>/2018/08/27/ddm/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>估值这个事情，不知道有多少人前仆后继的研究。毕竟，有一个准确的估值模型就可以发家致富了。然而现实生活中并不是想象中那么美好，估值理论一大堆，到底如何使用就见仁见智了。今天就来开始研究估值的模型。  </p><h2 id="价值的分类"><a href="#价值的分类" class="headerlink" title="价值的分类"></a>价值的分类</h2><ul><li>账面价值(Book Value)<br>理论上讲就是指资产的初始价格减去折旧</li><li><p>内在价值(Intrinsic Value)<br>指的是资产对应投资人来说的实际价值。内在价值其实就相当于是股票未来可以产生的现金流的现值。提到现值，就必须要提到折现率。每个人折现率不同，股票对每个人的内在价值也不同。  </p></li><li><p>市场价值(Market Value)<br>其实也就是市场的交易价格。交易价格经常偏离其实际内在价值，因此会产生套利空间。</p></li></ul><p>市场价值，也就是公允价格每天都可以看到，但股票的内在价值却是很难判断。因此，我们在这里所说的估值，就是要估股票的内在价值。  </p><p>另外，股票也分两种，普通股和优先股，我们先来研究普通股。  </p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>上面说了，股票估值实际上就是把未来的现金流折现成现值。那么我们就有几个问题了：  </p><ul><li>未来哪年会有现金流？</li><li>未来的现金流有多少？</li><li>折现率到底是多少？</li></ul><p>有了上面三个数据以后，我们就基本可以按照PV-FV的关系来进行折现了。  </p><p>基本的一个公式是：  </p><p><img src="http://www.doublure.cn/blog/180808/2E1lHlElLm.png?imageslim" alt="mark"></p><p>未来的现金流这个东西，基本靠半算半猜(这也是估值的一个最大难点)，靠的是对公司的理解。<br>而折现率相对比较好算，CAPM模型里准备了一个证券市场线SML，可以根据股票的历史β值(当然更精确的是先对历史β值进行校正)，市场的收益rm来计算股票的预期收益。公式如下：  </p><p><img src="http://www.doublure.cn/blog/180805/DJc9IbgL45.png?imageslim" alt="mark"></p><p>求出来折现率之后，我们就假设(注意是假设)我们会知道企业未来的现金流，然后我们就可以引用先人的智慧进行估值了。  </p><h2 id="DDM"><a href="#DDM" class="headerlink" title="DDM"></a>DDM</h2><p>Dividend Discount Model，也就是将未来的股利进行折现。我们前面也说过，普通股的股东主要靠两种方式赚钱：拿股利以及转让股票。转让股票相当于是在期末的一个额外终值，在这里，我们先假设我们要长期持有股票，并不转让（没错，把股票传给下一代。。。），仅从股利的层面来考虑。</p><h3 id="永续增长"><a href="#永续增长" class="headerlink" title="永续增长"></a>永续增长</h3><p>假设第0年的股利为D0，股利以后每年增长g，折现率，也就是普通股的权益成本为k，那么，这就相当于是一个永续增长的年金模型。  </p><p>我们用前面的年金知识，很容易可以得到：  </p><p><img src="http://www.doublure.cn/blog/180808/9F494Kf6Eh.png?imageslim" alt="mark"></p><p>如果N趋向于无穷大(接盘侠接一辈子盘。。。)，那么这个公式求极限就变成：  </p><p><img src="http://www.doublure.cn/blog/180808/DmbL240BEK.png?imageslim" alt="mark"></p><h3 id="两段模型"><a href="#两段模型" class="headerlink" title="两段模型"></a>两段模型</h3><p>上面这个公式看起来很简单，然而，过于理想化。最典型的问题在于，很难保证股利永远维持g增长一辈子。</p><p>于是，为了优化的更实际一点，我们把增长分为2段：</p><ul><li>以g1的增长率增长n年</li><li>然后以g2的增长率永续增长</li></ul><p>在这种模型下，股票的现值就等于这两种增长现值的相加。  </p><p>我们在上面计算了第一阶段增长的现值。<br>第二阶段的现值我们要分两部分计算：  </p><ul><li>第二阶段折合到第n年的现值</li><li>第n年的现值再转化成第0年的现值</li></ul><p>综合上面，可以得到(不多做解释了，详情参考货币的时间价值那一章)：  </p><p><img src="http://www.doublure.cn/blog/180808/Bg20dL0282.png?imageslim" alt="mark"></p><h3 id="三段模型"><a href="#三段模型" class="headerlink" title="三段模型"></a>三段模型</h3><p>上面这个看起来更合理了，但还是不够现实。因为从g1到g2的转化太过突然，正常情况下应该是缓慢由g1过渡到g2的。 </p><p>于是产生了3段模型：</p><ul><li>以g1增长n1年</li><li>然后增长率线性从g1变化到g2</li><li>从第0年开始，n2年后，增长率变为g2 </li></ul><p>经过推算（反正我是没推算出来），最终的公式应当是：<br><img src="http://www.doublure.cn/blog/180808/EC7hac47da.png?imageslim" alt="mark"></p><h2 id="DDM法的问题"><a href="#DDM法的问题" class="headerlink" title="DDM法的问题"></a>DDM法的问题</h2><p>DDM法看起来很有道理，但实际上真正的估值很少用这种方法。就拿中国来说，有几个公司发放股利呢？如果一直不分红，那估值岂不是为0？所以，我们还需要采用其他方法来进行估值。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 估值 </tag>
            
            <tag> 股利 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CAL,CML和SML</title>
      <link href="/2018/08/05/capital-market-line/"/>
      <url>/2018/08/05/capital-market-line/</url>
      <content type="html"><![CDATA[<p>​     <a id="more"></a></p><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><p>前面我们重点研究了：  </p><ul><li>不含Rf的有效边界的计算</li><li>包含Rf的有效边界的计算</li></ul><p>在上一篇的最后，我们做出了一个资产组合A与无风险组合Rf配置，所得到的均值-方差线，这条线长的是这个样子：  </p><p><img src="http://www.doublure.cn/blog/180805/mF1aIm6lke.png?imageslim" alt="mark"></p><p>实际上，图中的这条红线还有个专业的名字，叫做资本配置线(Capital Allocation Line)</p><h2 id="资本配置线"><a href="#资本配置线" class="headerlink" title="资本配置线"></a>资本配置线</h2><p>为什么上面这条红线叫资本配置线呢？  </p><ul><li>红线的左边端点，代表所有资本都投入了Rf。</li><li>红线右边的A点，代表所有资本都投入的风险资产，没有一分钱投入到了Rf上。  </li></ul><p>那么，红线上的部分，就代表了一部分投入到Rf，一部分买入风险资产A的情况。这条线就代表了对于Rf和A资产的资本配置的情况。<br>前面说过了，有些人投资愿意选A，但有些人能承担更高的风险，也追求更高的收益，我们假设他们能接受B点的资产组合。  </p><p>于是，如果B资产与Rf组合，又会得到一条新的线：  </p><p><img src="http://www.doublure.cn/blog/180805/ac83jC3aii.png?imageslim" alt="mark">  </p><p>也就是说，任何一个资产，与无风险资产进行组合，都可以得到其对应的资本配置线。因此，资本配置线是有无数条的。  </p><h2 id="市场资本线-Capital-Market-Line"><a href="#市场资本线-Capital-Market-Line" class="headerlink" title="市场资本线(Capital Market Line)"></a>市场资本线(Capital Market Line)</h2><p>假设我有了市场上所有资产的价格信息（仅仅是假设），于是我可以做出一条包含了市场上所有资产的有效边界。</p><p>如果我在有效边界里任选一个投资组合，配上无风险资产，那么根据上一节的内容，我们可以通过这个公式来计算收益：  </p><p><img src="http://www.doublure.cn/blog/180805/BIb3aAJ3c2.png?imageslim" alt="mark"></p><p>每个人投资，当然期望收益能最大。那么在风险<code>σp</code>一定的情况下，我只需要在有效边界上找到一个点，这个点的<code>(ra−rf)/σa</code>最大即可。</p><p>因此，这个问题就转化成了：<br>从Rf为起点做一条直线，这条直线与有效边界相交，求这条直线的斜率在哪种情况下最大？  </p><p>没错，就是直线和有效边界相切的时候，斜率最大。  </p><p>这里就引出了另外一个假设：市场上的投资者都很理性，他们都会购买斜率最大这一点的资产组合(就当是假设就好，实际上基本不可能)。</p><p>在图像上，就是这样表示，M点就是切点：  </p><p><img src="http://www.doublure.cn/blog/180805/bJjj3DEe4I.png?imageslim" alt="mark">  </p><p>M点与Rf点连成的线，就是市场资本线(CML)。可以这么理解，CML就是在无数条CAL中，选出收益/风险比最大的一条。因此，CML只有一条。  </p><p>M点就被称为市场组合。市场组合有这么几个特点：  </p><ul><li>包括市场中所有的风险资产</li><li>不包括任何无风险资产</li></ul><p>我们把上面的公式中的某个特定资产A换成市场组合M,就可以得到公式：  </p><p><img src="http://www.doublure.cn/blog/180805/1H8AcfeA0j.png?imageslim" alt="mark"></p><p>我们说过，M点是CAL中斜率最大的一点，实际上，这个斜率还有一个名字，叫做夏普比率(Sharp Ratio)，定义如下：  </p><p><img src="http://www.doublure.cn/blog/180805/dh3JAdHfjB.png?imageslim" alt="mark"></p><p>于是，很容易就能得到，CML是<code>Sharp Ratio</code>最大的一条线，也应该是收益/风险最优的一条线。  </p><h2 id="市场证券线-Securities-Market-Line"><a href="#市场证券线-Securities-Market-Line" class="headerlink" title="市场证券线(Securities Market Line)"></a>市场证券线(Securities Market Line)</h2><p>从上面的推导得到一个市场组合M后，假设我们又选中另外一个资产P，与M进行组合，那么：  </p><ul><li>P与M资产构成的有效边界一定与M点的CML线相交(因为如果P的权重为0，就纯粹是选择M，M点一定在CML线上)</li><li>P与M构成的有效边界与CML只有一个交点(因为所有有效边界必定在CML的右下方，因此与CML最多就只有一个交点)</li></ul><p>如果此组合中P的权重为<code>α</code>，M的权重为<code>1-α</code>，那么<code>α=0</code>时，即为市场组合M。  </p><p>在这种情况下，利用均值-方差理论求M点的斜率，也就是对P和M的组合在<code>α=0</code>处求微分：  </p><p><img src="http://www.doublure.cn/blog/180805/CkkIi32AC0.png?imageslim" alt="mark"></p><p>当然，M点的斜率还可以直接用前面Sharp Ratio来得到，于是：  </p><p><img src="http://www.doublure.cn/blog/180805/ckDl4aJCgC.png?imageslim" alt="mark"></p><p>我们定义β为：  </p><p><img src="http://www.doublure.cn/blog/180805/lG0eGK1029.png?imageslim" alt="mark"></p><p>于是就得到了一个资产定价模型(Capital Assets Pricing Model)的公式： </p><p><img src="http://www.doublure.cn/blog/180805/DJc9IbgL45.png?imageslim" alt="mark"></p><p>根据这个模型，资产组合的收益率等于无风险收益率加上风险溢价。无风险收益率就是公式中的<code>Rf</code>,风险溢价就是右边的部分。  </p><p>仔细观察公式的风险溢价部分，我们发现有两个地方存在不确定性(风险)：  </p><ul><li>Rm，也就是市场的风险，是系统性风险</li><li>β，也就是单个股票相对于市场风险的相关程度，也是系统性风险</li></ul><p>我们前面所说的通过分散投资来减少风险，可以减少的是非系统性风险，市场风险是没办法分散的。  </p><p>通过观察上面CAPM的公式，我们发现，Rp相对于β来说也是线性关系。因此，我们以β为X轴，Rp为Y轴，继续做散点图，就可以得到证券市场线(SML)。  </p><p>最终做出的SML形状大致是这样子：  </p><p><img src="http://www.doublure.cn/blog/180805/lcHKi566DG.png?imageslim" alt="mark">  </p><p>SML曲线反映的是资产系统性风险与收益的关系，对整个市场内的资产（包括组合）都适用。如果某项资产的β-收益点位于SML上方，就代表其在同等市场风险条件下，收益更高，相当于被低估了。反之，资产被高估。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 投资组合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资产组合的有效边界</title>
      <link href="/2018/08/05/efficient-frontier/"/>
      <url>/2018/08/05/efficient-frontier/</url>
      <content type="html"><![CDATA[<p>​    <a id="more"></a></p><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><ul><li>协方差的概念</li><li>方差/协方差矩阵</li><li>资产组合标准差的计算  </li></ul><h2 id="有效边界"><a href="#有效边界" class="headerlink" title="有效边界"></a>有效边界</h2><p>会计算资产组合的标准差和期望以后，我们就可以按照自己的想法来调配各种资产，形成组合，然后再计算期望收益和风险了。  </p><p>作为风险厌恶者，一般的投资人基本都会有两个想法：  </p><ul><li>风险一定，选择收益最大的组合</li><li>收益一定，选择风险最小的组合  </li></ul><p>假设有下面的资产，我们求出了协方差矩阵：  </p><p><img src="http://www.doublure.cn/blog/180804/m0AhbA5bCh.png?imageslim" alt="mark">  </p><p>一般来说，我们采用确定收益率，并把标准差最小化的方法，于是我们给出一个资产组合权重表，每个组合对应的权重，以及整个组合的期望和标准差用公式先计算出来：  </p><p><img src="http://www.doublure.cn/blog/180804/7J5HhGBDj3.png?imageslim" alt="mark">  </p><p>然后在第8列指定目标的收益率。  </p><p>然后用规划求解就可以计算出最终的权重。规划求解的条件是：  </p><ul><li>权重合计为1  </li><li>目标收益率等于组合的收益率期望</li><li>标准差要最小</li><li>允许卖空</li></ul><p>于是可以得到8个资产组合的最优化的标准差和期望。上图中已经给出了计算结果。  </p><p>我们把8种组合，以及4种资产自身的标准差为横坐标，收益率为纵坐标，做散点图，得到下面的图表：  </p><p><img src="http://www.doublure.cn/blog/180804/h2c4h7aKLf.png?imageslim" alt="mark"></p><p>图中的蓝线和红线表示资产组合对应的风险-收益曲线，明显可以看得出，红线部分相对于蓝线部分，在同等风险的条件下，蓝线上的收益更大。</p><p>于是乎，蓝线这部分，就被称为这4种资产的有效边界(Efficient Frontier)。这代表着，对于特定的风险来说，蓝线上的点是可以达到的最大的收益。  </p><p>这个有效边界里的资产都是有风险资产，现实生活中还有一种很重要的资产：无风险资产，比如说国债和银行利息。如果把无风险资产也引入，有效边界会是什么样子？  </p><h2 id="包含无风险资产的有效边界"><a href="#包含无风险资产的有效边界" class="headerlink" title="包含无风险资产的有效边界"></a>包含无风险资产的有效边界</h2><h3 id="使用Excel进行计算"><a href="#使用Excel进行计算" class="headerlink" title="使用Excel进行计算"></a>使用Excel进行计算</h3><p>类似的，我们把年化收益为7%的无风险资产加入到资产组合中：</p><p><img src="http://www.doublure.cn/blog/180804/5kGiaEbe0K.png?imageslim" alt="mark"></p><p>然后依旧使用规划求解，确定几个收益点，使其标准差最小化,得到一张新的图：  </p><p><img src="http://www.doublure.cn/blog/180804/JB1Aa38JE8.png?imageslim" alt="mark">  </p><p>我们看到，无风险资产(Rf)的引入，使有效边界变成了一条直线，直线的截距即为Rf，意味着这时，资产组合里只有无风险资产，标准差为0，也就是没有风险。  </p><p>另外，非常重要的一点，Rf的引入，又进一步优化了投资组合的有效边界。原先不包含Rf的有效边界，都落在包含Rf的直线的下方，代表着在相同收益的情况下，引入Rf有效的降低了风险。  </p><p>那么，为什么加入Rf之后有效边界会是一条直线呢?  </p><h3 id="直线的由来"><a href="#直线的由来" class="headerlink" title="直线的由来"></a>直线的由来</h3><p>我们刚才求出了不考虑Rf的情况下，资产组合的有效边界。这条边界是数学上最优化的模型，但如果要具体选择线上的哪一点对应的资产进行投资，每个人就见仁见智了。  </p><p>比如说，下面这条有效边界有两个点，分别对应不同的风险和收益。  </p><p><img src="http://www.doublure.cn/blog/180805/4J1ElHaLfh.png?imageslim" alt="mark"></p><p>A与B相比较，A的风险比B小，收益也比B小，但有的人追求稳妥，最终会选择投资A，也有的人追求收益，会选择投资B。  </p><p>但不管投资A还是投资B，都相当于是投资了某个特定的资产组合。这里的特定，是指资产组合里各个资产的权重已经确定了。<br>那么，如果把这个特定的资产组合看做是一个整体，他也有自己的期望，和方差，也就是收益和风险。  </p><p>如果此时再把Rf引入，我们相当于是把模型简化成了2个资产组合，这两个资产，一个为无风险，一个为点A对应的资产组合。  </p><p>具体推导过程如下图：  </p><p><img src="http://www.doublure.cn/blog/180805/IDalg455GB.png?imageslim" alt="mark"></p><p>最后，得到的公式是：  </p><p><img src="http://www.doublure.cn/blog/180805/BIb3aAJ3c2.png?imageslim" alt="mark"></p><p>显然，这是一条截距为rf的直线，在图中表示如下：  </p><p><img src="http://www.doublure.cn/blog/180805/mF1aIm6lke.png?imageslim" alt="mark"></p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 有效边界 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资产组合</title>
      <link href="/2018/08/05/portfolio-management/"/>
      <url>/2018/08/05/portfolio-management/</url>
      <content type="html"><![CDATA[<p>​    <a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多数人应该能看懂这张图所阐述的道理：   </p><p><img src="http://www.doublure.cn/blog/180804/LLl112CIg9.png?imageslim" alt="mark"></p><p>鸡蛋不能放在一个篮子。同样一句话说，投资不能都投在一个资产上。这里更多的是从风险上考量，每种资产都会有风险，一旦风险真的变成了坏账，分散性差的投资就全军覆没了。  </p><p>合理的分散投资，可以在维持收益不变的基础上，降低投资风险。 </p><p>当然，如果你把资本分散投入到高风险资产，最后也有可能狗带.<br>说到这里，不由想起来一个笑话：  </p><blockquote><p>“自从跟网贷大佬们学会了分散投资，鸡蛋不要装在一个篮子里，聪明的我把资金分散放到了下列平台：投融家、钱妈妈、银票网、善林金融、唐小僧、联璧……结果现在所有维权群里都能看到我的身影。”</p></blockquote><p>投资最核心的是两点：收益和风险。多数投资者应该都是风险厌恶性(Risk Averse)的，因此，如果承担的风险越高，所期望的收益应该越大。  </p><p>那么怎么来衡量资产的收益和风险呢？现代的资产理论有一个核心的理论基础：  </p><ul><li>投资组合的收益，可以通过组合的统计期望来表示</li><li>投资组合的风险，可以通过组合的标准差来表示</li></ul><p>于是，统计学就派上用场了。  </p><h2 id="投资组合的期望"><a href="#投资组合的期望" class="headerlink" title="投资组合的期望"></a>投资组合的期望</h2><p>假设一个资产组合中包括了N项资产，那么和之前计算加权平均资本成本（WACC）一样，投资组合的期望收益可以通过一个简单的加权公式来计算：  </p><p><img src="http://www.doublure.cn/blog/180804/6faEG1IjmG.png?imageslim" alt="mark"></p><p>其中：  </p><p><img src="http://www.doublure.cn/blog/180804/6ihek3JmeG.png?imageslim" alt="mark">  </p><p>统计学的期望其实就是线性求加权平均值，因此这个公式适用于任何数量的资产构成的资产组合。  </p><h2 id="投资组合的标准差"><a href="#投资组合的标准差" class="headerlink" title="投资组合的标准差"></a>投资组合的标准差</h2><p>统计学上，什么是标准差？  </p><p>标准差实际上是对样本的数据点偏离统计期望的程度的表示。<br>如果用公式来表示：  </p><p><img src="http://www.doublure.cn/blog/180804/AE9kaFh0D0.png?imageslim" alt="mark"></p><p>既然标准差的计算公式并不是线性的，因此简单把各项资产收益率的方差进行加权平均是没有任何意义的。  </p><p>那么应该怎么求组合的标准差呢？这里需要引入一个新的概念。</p><h3 id="资产之间的相关性"><a href="#资产之间的相关性" class="headerlink" title="资产之间的相关性"></a>资产之间的相关性</h3><p>衡量一个资产的收益率的波动程度用方差，那么如何衡量两个资产的波动程度呢？把上面的方差公式改改：  </p><p><img src="http://www.doublure.cn/blog/180804/GBHlmmdakh.png?imageslim" alt="mark">  </p><p>其中：  </p><ul><li>X,Y代表两项资产</li></ul><p>上面的指标被称为X和Y的协方差(Covariance)。<br>然后再定义一个指标，叫做X和Y的相关系数：  </p><p><img src="http://www.doublure.cn/blog/180804/87G2HhBbLJ.png?imageslim" alt="mark">  </p><p>不难发现，如果X和Y完全同步，那么相关系数就是1，如果X和Y的变化正好相反，那么相关系数就是-1  </p><blockquote><p>Excel提供了CORREL函数求两个矩阵的相关系数，这个在分析相关性上非常实用</p></blockquote><h3 id="两种资产组合的标准差"><a href="#两种资产组合的标准差" class="headerlink" title="两种资产组合的标准差"></a>两种资产组合的标准差</h3><p>假设某个投资组合中有两种资产，那么这个投资组合的方差可以这样计算：  </p><p><img src="http://www.doublure.cn/blog/180804/D34gC2k018.png?imageslim" alt="mark"></p><p>于是可以得出：  </p><p><img src="http://www.doublure.cn/blog/180804/b3hj1Kg2K6.png?imageslim" alt="mark"></p><p>于是可以得出一个结论：<br>如果两种资产的协方差越小，越靠近-1，整个资产组合的方差越小，也就是风险可以得到分散。  </p><h3 id="多种资产组合的标准差"><a href="#多种资产组合的标准差" class="headerlink" title="多种资产组合的标准差"></a>多种资产组合的标准差</h3><p>与两种资产组成的组合计算标准差相似，多个资产构成的组合的方差可以这样表示：  </p><p><img src="http://www.doublure.cn/blog/180804/lCEfBKhI5J.png?imageslim" alt="mark">  </p><p>例如，3个资产组成的组合的方差为：  </p><p><img src="http://www.doublure.cn/blog/180804/fIlkgI88Am.png?imageslim" alt="mark">    </p><p>这个公式，实际上是一种矩阵的表达：  </p><p><img src="http://www.doublure.cn/blog/180804/Ei0mIdhaL4.png?imageslim" alt="mark"></p><p>W矩阵在我们确定资产权重的时候很容易可以得到，接下来我们只要得到V矩阵，也就是方差/协方差矩阵，就可以计算出来组合的标准差了。  </p><p>这个方差/协方差矩阵长的应该是这个样子：  </p><p><img src="http://www.doublure.cn/blog/180804/6Jjcej64Cj.png?imageslim" alt="mark"></p><p>方差/协方差矩阵应该怎么算呢?  </p><p>首先，方差/协方差矩阵是资产组合中各种资产的相关性，与其在组合中的权重没有关系。  </p><p>其次，如果已经有了每项资产的N个收益率数据，那么每个收益率的概率均等，为<code>1/N</code>。  </p><p>再根据协方差的公式，就可以得到方差/协方差矩阵形式为：  </p><p><img src="http://www.doublure.cn/blog/180804/6aJgi13af7.png?imageslim" alt="mark">  </p><p><img src="http://www.doublure.cn/blog/180804/Jiaia7HF4E.png?imageslim" alt="mark">  </p><p>什么是差异矩阵呢？实际上就是每项资产的实际收益，减去其平均收益得到的矩阵。  </p><p>由此，我们就可以计算多种资产的风险度量，也就是标准差了。  </p><h2 id="使用Excel计算资产组合标准差"><a href="#使用Excel计算资产组合标准差" class="headerlink" title="使用Excel计算资产组合标准差"></a>使用Excel计算资产组合标准差</h2><p>利用Excel的数组函数，可以相当方便的求出组合的标准差。  </p><p>例如，有一组数据，包含了4个资产5年的收益率，分别计算了单支资产的期望和标准差：  </p><p><img src="http://www.doublure.cn/blog/180804/0kFLkm8260.png?imageslim" alt="mark">  </p><p>然后确定权重，假定为各25%。  </p><p>然后计算协方差矩阵，使用矩阵乘法即可。  </p><p><img src="http://www.doublure.cn/blog/180804/gkdmllH0ge.png?imageslim" alt="mark">  </p><p>最后利用协方差矩阵和权重，计算资产组合标准差即可。<br><img src="http://www.doublure.cn/blog/180804/IcHh7dag9e.png?imageslim" alt="mark">  </p><p>在计算过程中，要注意数组公式，也就是Ctrl+Shift+Enter的使用。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 投资组合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资本预算决策方法</title>
      <link href="/2018/08/03/capital-budgeting-decision-method/"/>
      <url>/2018/08/03/capital-budgeting-decision-method/</url>
      <content type="html"><![CDATA[<p>​    <a id="more"></a></p><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><p>资本预算考虑：  </p><ul><li>增量现金流</li><li>税后现金流</li></ul><p>资本预算不考虑：</p><ul><li>沉没成本</li><li>融资成本  </li></ul><p>现金流分3种：</p><ul><li>初始投资IO</li><li>年度税后现金流ATCF</li><li>剩余现金流TCF  </li></ul><p>在我们确定了3种现金流的金额之后，就可以来决策了。  </p><h2 id="决策方法"><a href="#决策方法" class="headerlink" title="决策方法"></a>决策方法</h2><p>首先考虑这样一个现金流，作为例子：  </p><p><img src="http://www.doublure.cn/blog/180802/dK88Hdd4IC.png?imageslim" alt="mark"></p><ul><li>期初投入62680元</li><li>从第一年开始，每年获得24248元的增量现金流</li><li>第5年有18000元的剩余现金流</li></ul><h3 id="投资回收期法-Payback-Period"><a href="#投资回收期法-Payback-Period" class="headerlink" title="投资回收期法(Payback Period)"></a>投资回收期法(Payback Period)</h3><p>这个方法的思路很简单，我投入了62680元，每年回收24248元，我需要多少年才能收回成本？初中数学了解一下，直接用<code>62680/24248=2.58</code>。  </p><p>也就是说，我需要用2.58年收回成本，如果公司期望3年收回成本，那么2.58年也是可以接受的。  </p><p>看似很有道理哦，也很好实现，但投资回收期法有几个问题：  </p><ul><li>忽略了现金流的时间价值</li><li>忽略了未来可能的现金流流出。万一这个项目第4年又流出了40000美金，按照回收期法，结果依旧是2.58年，项目依旧可以接受。  </li></ul><h3 id="折现回收期法-Discounted-Payback-Period"><a href="#折现回收期法-Discounted-Payback-Period" class="headerlink" title="折现回收期法(Discounted Payback Period)"></a>折现回收期法(Discounted Payback Period)</h3><p>相对于普通的回收期法，折现回收期考虑了现金流的时间价值。<br>于是我们把从第一年到第5年的现金流依次折现，然后与初始投资相加，一直到现值大于零为止，得到一个年数，就是折现后的回收期。  </p><p>使用折现回收期法，计算出的回收期为&gt;3年。因此，如果公司要求3年回收IO的话，从数字上来看这个项目是不能接受的。  </p><p><img src="http://www.doublure.cn/blog/180802/HlbB1FI744.png?imageslim" alt="mark"></p><p>虽然折现回收期考虑了货币的时间价值，但是，并不是所有项目周期内产生的现金流都被列入计算。如果想改进这一点，就得使用下面的净现值法。</p><h3 id="净现值法-NPV"><a href="#净现值法-NPV" class="headerlink" title="净现值法(NPV)"></a>净现值法(NPV)</h3><p>前面的折旧回收期，虽然考虑了现值，但他只考虑了能够补偿初始现金流的现值部分，后面的并未考虑。<br>如果考虑全部现金流，他的现值(折算到第0年)为：  </p><p><img src="http://www.doublure.cn/blog/180802/kDCijGiAcg.png?imageslim" alt="mark"></p><p>然后把这个现值减去初始投资，就得到了整个项目的净现值：  </p><p><img src="http://www.doublure.cn/blog/180802/165dKK8h5d.png?imageslim" alt="mark"></p><p>也就是说，得到了整个项目的终值，折合到今天的价值。如果这个NPV为正数，就可以接受，如果为负数，就不能接受。  </p><p>Excel提供了NPV公式，来计算一组现金流的净现值：  </p><p><img src="http://www.doublure.cn/blog/180802/GDlIa6aBc4.png?imageslim" alt="mark"></p><blockquote><p>在使用NPV函数的时候，如果直接把IO也作为现金流包含在NPV函数里，例如<code>NPV(B9,B2:B7)</code>，那么得到的是第-1年的NPV，并不是真正第0年的NPV。这个时候，需要用(1+hurdle rate)来校正。</p></blockquote><p>从理论上来讲，NPV法是资本预算中最科学的一种方法。  </p><h3 id="盈利能力指数-Profitablity-Index"><a href="#盈利能力指数-Profitablity-Index" class="headerlink" title="盈利能力指数(Profitablity Index)"></a>盈利能力指数(Profitablity Index)</h3><p>NPV给出了净现值的绝对值，不过，这可能忽略项目规模。如果一个初始投资为1000的NPV为10，和一个初始投资为100，NPV为8的项目比较，从NPV的绝对值上来看，似乎第一个项目更好，但实际上，第二个项目的收益率要更高。从这点来讲，这个与销售额和利润的关系类似。  </p><p>于是，我们引入了盈利指数这个概念。</p><p>简单的讲，盈利指数就等于项目回收的现金流，除以初始投资：  </p><p><img src="http://www.doublure.cn/blog/180802/KfFbBfIGCb.png?imageslim" alt="mark"></p><p>或者，  </p><p><code>PI=NPV/IO+1</code>  </p><p>很显然，如果NPV大于零，PI就大于1，项目就可以被接受。  </p><h3 id="内部收益率-IRR-MIRR"><a href="#内部收益率-IRR-MIRR" class="headerlink" title="内部收益率(IRR/MIRR)"></a>内部收益率(IRR/MIRR)</h3><p>还是从NPV的角度上考虑，如果NPV为0，代表项目处在可以与不可以接受的临界点，这个时候，可以计算出一个折现率，这个折现率就被称为内部收益率。  </p><p>如果计算出来的内部收益率大于要求收益率，就代表项目可以被接受。  </p><p>内部收益率可以通过下面公式来计算：  </p><p><img src="http://www.doublure.cn/blog/180802/121176ecmK.png?imageslim" alt="mark"></p><p>鉴于这是一个多次方程，没有什么快速方法来求解，只能逐个试错。Excel提供了IRR函数，来计算内部收益率。<br>IRR虽然非常常用，但也是存在一定问题的：  </p><ul><li>方程不一定有唯一解。如果一个项目有多个现金流流出，那么就会有多个IRR</li><li>内部收益率法默认现金流以IRR继续投资，但IRR并不一定能反应真实的再投资收益。Excel有一个内置函数MIRR，可以对IRR进行再投资收益率的校正。  </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>确定了现金流和决策方法之后，就可以对资本预算进行下一步，也就是敏感度分析和优化了。敏感度分析涉及不同hurdle rate下的净现值，优化涉及到规划求解，在这里就不详细探讨了。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 资本预算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资本预算</title>
      <link href="/2018/07/31/capital-budgeting/"/>
      <url>/2018/07/31/capital-budgeting/</url>
      <content type="html"><![CDATA[<p>​     </p><a id="more"></a><h2 id="什么是资本预算"><a href="#什么是资本预算" class="headerlink" title="什么是资本预算"></a>什么是资本预算</h2><p>在企业报表的部分我们说过，企业主要是在做经营，投资和筹资三件事情。筹资，和我们资本成本有很大关系。既然筹到了资，那么一定需要把资产投出去，让他变成更多的资本。  </p><p>在企业投资的时候，当然要事先考量投资的收益以及自己的成本。只有在收益大于投资的时候，企业才有动力去投资。  </p><p>资本预算就是主要服务与此。简单点讲，资本预算就是企业确定投资预期收益，并决策是否到底要投资的一种方法。  </p><h2 id="如何进行资本预算"><a href="#如何进行资本预算" class="headerlink" title="如何进行资本预算"></a>如何进行资本预算</h2><p>在资本预算的过程中，公司最关注的还是投资的项目是否能够产生现金流入。从股东的层面上来讲，只有账面有现金，才能有钱分红。一般来说，单个项目的资本预算可以这样来做：  </p><ol><li>确定现金流</li><li>根据现金流进行决策  </li></ol><h2 id="确定现金流"><a href="#确定现金流" class="headerlink" title="确定现金流"></a>确定现金流</h2><p>资本预算里对其所关心的现金流有这么几个要求：  </p><ul><li>增量现金流<br>如果新项目和老项目的产品存在相互替代，那么资本预算只考虑多出来的那部分现金流。  </li><li>税后现金流<br>毕竟，所需要交的税是不属于公司的，公司只考虑税后现金流。  </li></ul><p>对于现金流，还有几点：  </p><ul><li><p>不考虑沉没成本<br>对于一笔钱来说，不管新项目上还是不上，都必须要花的话，那么他就是沉没成本。资本预算是不予以考虑的。  </p></li><li><p>不考虑融资成本<br>这个也不难理解，资本预算是先考虑收益，然后再对比成本。<br>融资成本实在资本成本那里计算的，并不在资本预算的现金流范围之内。  </p></li></ul><h3 id="现金流分类"><a href="#现金流分类" class="headerlink" title="现金流分类"></a>现金流分类</h3><p>对于一个项目来说，现金流按照项目的推进一般分三类：  </p><h4 id="初始投资-IO"><a href="#初始投资-IO" class="headerlink" title="初始投资(IO)"></a>初始投资(IO)</h4><p>Initial Outlay，表示公司在项目初期需要投入的现金流。这个现金流主要包括以下几个部分：  </p><ol><li>项目的价格（例如设备费用）</li><li>运输费，安装费，培训费</li></ol><p>以上两个项目需要都计入折旧基础，也就是说，折旧其实不仅仅只包括固定资产自身的价格，也包括与固定资产相关联的附加费用。  </p><ol start="3"><li>原有设备的残值</li></ol><p>上了新的项目，旧的机器还是有残值的。因此，残值相当于是现金流的流入。不过，如果机器的残值和账面价值不同，那么就会附带有税收影响。  </p><p>例如，一台机器原价100万，预期使用10年。用线性折旧5年之后，以60万的价格卖出，税率是25%。<br>对于这种情况，使用5年后，机器的账面价格为50万，而以60万售出，税前现金流增加了10万，而这10万需要付25%的税，因此，税后的现金流增加值为<code>10*（1-0.25）= 7.5</code>万  </p><ol start="4"><li>营运资本的变动<br> 如果新项目投入后，需要增加净营运资本，那么营运资本的增加值也应当被计入初始投资里。  </li></ol><p>综上所述，初始投资IO的计算公式为：  </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始投资 = </span><br><span class="line">项目价格</span><br><span class="line"><span class="addition">+相关费用(运输，安装，培训)</span></span><br><span class="line"><span class="deletion">-残值</span></span><br><span class="line"><span class="addition">+处理残值带来的税费</span></span><br><span class="line"><span class="addition">+净营运资本的增加</span></span><br></pre></td></tr></table></figure><h4 id="年度税后现金流-ATCF"><a href="#年度税后现金流-ATCF" class="headerlink" title="年度税后现金流(ATCF)"></a>年度税后现金流(ATCF)</h4><p>ATCF考察的是项目在运转后，每年的现金流回报。ATCF一般包括几个现金流组成部分：  </p><ol><li><p>收入增加<br>  这个并不难理解，注意这个收入增加是净增加额</p></li><li><p>成本节约<br>  如果上一个项目，能让以后少花钱，也是可以考虑的。</p></li><li><p>附加费用<br>  如果投入了新的项目导致人工维修等费用增加的话，这部分费用需要在现金流中扣除。  </p><p>  不难看出，上面这3个部分都属于税前现金流的增加。需要扣除税率，来得到税后现金流。  </p></li><li><p>净营运资本变化<br>  和初始投资IO一样，每年净运营资本可能因为很多原因发生变化，最典型的就是通货膨胀了。所以，也需要把经运营资本的变化也考虑在内。   </p><p>  净运营资本的增加使用的是税后的现金流，因此不需要用税率进行调整。  </p></li><li><p>折旧收益<br>  折旧收益是很容易被忽视的一项影响现金流的项目。因为折旧是非现金费用，是税前扣除的，因此也具有税盾的作用。<br>  那么这个税盾的值是多少呢？  </p><p>  就直接用新项目每年的折旧相对于旧项目每年折旧费用的增加量，乘上税率就可以。  </p></li></ol><pre><code>综合上面5点，我们可以计算出税后的年度税后现金流为： ![mark](http://www.doublure.cn/blog/180802/iAEggKGLCA.png?imageslim)然后再把`-Dn(1-t)+Dn`合并一下，就变成了：</code></pre><p>综合上面5点，我们可以计算出税后的年度税后现金流为：  </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">年度税后现金流=  </span><br><span class="line"></span><br><span class="line">(附加收入</span><br><span class="line"><span class="addition">+成本节约</span></span><br><span class="line"><span class="deletion">-附加费用)*(1-税率)</span></span><br><span class="line"><span class="deletion">-净营运资本的增加</span></span><br><span class="line"><span class="addition">+折旧费用增加*税率</span></span><br></pre></td></tr></table></figure><h4 id="剩余现金流-TCF"><a href="#剩余现金流-TCF" class="headerlink" title="剩余现金流(TCF)"></a>剩余现金流(TCF)</h4><p>在项目末期所产生的现金流。一般包括停产，回收净营运资本，处理残值等等。  </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">剩余现金流=  </span><br><span class="line">净营运资本变化的回收</span><br><span class="line"><span class="addition">+残值</span></span><br><span class="line"><span class="deletion">-(残值-账面价值)*税率</span></span><br><span class="line"><span class="deletion">-停产成本*(1-税率)</span></span><br></pre></td></tr></table></figure><p>确定了每个阶段的现金流之后，我们就可以进行下一步决策了。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 资本预算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资本成本脑图</title>
      <link href="/2018/07/29/cost-of-capital-mindmap/"/>
      <url>/2018/07/29/cost-of-capital-mindmap/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a>   <p><img src="http://www.doublure.cn/blog/180729/EIe5cbaGia.png?imageslim" alt="mark"></p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 资本成本 </tag>
            
            <tag> 脑图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算加权平均资本成本</title>
      <link href="/2018/07/29/wacc/"/>
      <url>/2018/07/29/wacc/</url>
      <content type="html"><![CDATA[<p>​    <a id="more"></a></p><h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><p>前面我们花相当的篇幅研究了个别资本成本，也就是长期借款，债券，普通股和优先股的资本成本。  </p><p>有了个别资本成本之后，我们当然不能简单的把资本成本加起来求算术平均，不然就会得到类似于郭敬明和姚明的平均身高为一米八的滑稽结果。  </p><p>试想这样一种情况，你今年正在进行理财，余额宝投入10万，年化收益3%，银行理财投20万，年化收益为5%， P2P投入10万，年化收益为10%。<br>问：一年下来总的年化收益为多少？  </p><p>我相信大家都不会简单的把3个年化收益相加求平均，得到6%的答案。因为，每个理财的投放额的权重是不一样的，对最终年化收益的贡献也不同。  </p><p>对于资本成本也是一样，若要求真正的资本成本，我们得先知道，每一项资本的权重是多少。  </p><h2 id="权重的确定"><a href="#权重的确定" class="headerlink" title="权重的确定"></a>权重的确定</h2><p>确定每一项资本的权重，一般有3种方法  </p><h3 id="账面价值权重"><a href="#账面价值权重" class="headerlink" title="账面价值权重"></a>账面价值权重</h3><p>反映的是每一项资本在入账时，记录的资本价值。<br>例如，如果发行了1万股的普通股，每股发行价为10元，那么普通股账面价值就是10万元。  </p><p>那么问题来了，像普通股这种东西是可以交易的，会有一个市场公允价格，如果后面股价从10元涨到了20元，那么很明显，普通股的资本成本在实际的资本中所占的比例要高了。  </p><p>因此，账面价值权重只是反映了一个历史权重。  </p><h3 id="市场价值权重"><a href="#市场价值权重" class="headerlink" title="市场价值权重"></a>市场价值权重</h3><p>如上面所说，市场价值权重可以反映市场运行当中公司真正的资本成本。  </p><p>市场价值权重需要先把各项资本按照市场价值来进行计算，然后得到相应的权重比例。  </p><h3 id="目标资本结构权重"><a href="#目标资本结构权重" class="headerlink" title="目标资本结构权重"></a>目标资本结构权重</h3><p>公司在经营的时候，很有可能已经事先根据市场测算出了一个最优的权重，使得资本成本得到最优解。随着市场的进行，管理层很有可能会朝着这个方向努力，达到最优的资本权重。  </p><p>因此，也可以根据目标资本权重来确定各项资本的权重。  </p><h2 id="WACC"><a href="#WACC" class="headerlink" title="WACC"></a>WACC</h2><p>有了个别资本成本，以及对应的权重之后，我们就可以计算加权平均资本成本了。计算公式很简单：  </p><p><img src="http://www.doublure.cn/blog/180729/J6AfFiKbHB.png?imageslim" alt="mark"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，不考虑发行成本的资本成本的计算就可以计算出来了。  </p><p>后期还可以再深入的内容有：  </p><ul><li>考虑发行成本</li><li>考虑边际资本成本（阶梯函数）</li></ul>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 资本成本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>债务成本的计算</title>
      <link href="/2018/07/29/cost-of-debt/"/>
      <url>/2018/07/29/cost-of-debt/</url>
      <content type="html"><![CDATA[<p>​     <a id="more"></a></p><p>前面一节引入了企业资本成本的问题，我们提到，企业的筹资成本包括债务和权益成本。  </p><h2 id="上节回顾"><a href="#上节回顾" class="headerlink" title="上节回顾"></a>上节回顾</h2><p>上一节主要研究了权益成本，包括普通股和优先股权益成本。普通股成本可以用两种方式来计算：  </p><ul><li>DDM折现法</li><li>CAPM法，利用β来计算<br>优先股的成本可以直接用永续年金的方法来计算。  </li></ul><p>其实上一节还落了一点：权益成本还有一种：留存收益成本。也就是说，企业在赚了钱之后，只把利润的一部分进行了分红，剩下的留在企业，继续用来发展企业。  </p><p>既然没有把好处都分给股东，那么股东自然对留下的这部分钱是有收益的期望的。这个期望就等于普通股的收益。也就是说，留存收益的资本成本就等于<strong>没有发行成本的</strong>普通股成本。  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Kre</span> = D1/pv +g</span><br></pre></td></tr></table></figure><p>这里： </p><ul><li>Kre就是留存收益的成本</li><li>D1是预计明年的股利</li><li>Pv是股票当前的价格</li><li>g是预计股利每年的增长率</li></ul><h2 id="债务成本"><a href="#债务成本" class="headerlink" title="债务成本"></a>债务成本</h2><p>前面说过，这里的债务都指的是长期债务。也分两种：  </p><ul><li>长期借款</li><li>长期债券</li></ul><p>现在以长期债券为例，计算债券的债务成本。  </p><p>根据现值和终值的理论，长期债券的现值等于未来每年所收到的利息，以及债券到期后本金的折现到现在的现值。  </p><p>根据前面的公式：  </p><p><img src="http://www.doublure.cn/blog/180728/FiF9GAGA18.png?imageslim" alt="mark"></p><p>这两项中，第一项就是所有利息的折现的现值，第二项是本金折现成的现值。  </p><p>公式里的参数分别是：  </p><ul><li>pmt：每年的利息</li><li>FV：债券到期回收的本金</li><li>kd: 债券的成本</li><li>VB: 债券的现值</li></ul><p>上面这个公式直接用一般的数学方法是算不出来的，一般采用试错的方法来得到。  </p><p>当然，在Excel里，可以使用RATE函数。怎么来理解呢？一步一步来。  </p><ul><li>期初花了PV的钱购买了一个债券</li><li>每一期回收PMT的利息，直到最后一期</li><li>最后一期所得到的终值价值为FV</li></ul><p>有了这些内容，就可以使用RATE函数求解了。  </p><p>长期借款的计算方式和长期债券相仿，就不再详细介绍了。</p><h2 id="税盾"><a href="#税盾" class="headerlink" title="税盾"></a>税盾</h2><p>用上面的方法，我们就可以算出来一个债务成本。这个成本的计算并没有考虑税。企业在支付息税的时候，先付息，再付税，那么税收对企业债务成本有什么影响呢？  </p><p>举个例子来看。  </p><p>如果有两家企业，息税前利润（EBIT）都是300，不同的是，公司A有100块借款利息要付，而公司B没有任何借款。我们假设企业所得税税率为25%。  </p><p>那么，公司A扣除利息和税后的收入为：<code>200-200*0.25=150</code><br>公司B扣除息税后的净利润为：<code>300-300*0.25=225</code>  </p><p>可以看得出来，税前净利润A比B少了100，而税后只少了75，利息的存在具有抵税的作用。  </p><p>所以，企业所需要还的利息当中，有一部分是用来抵税的，因为如果你不借款，就要交更多的税。剩下的部分，是企业真正要负担的，也就是kd(1-t)。其中，</p><ul><li>kd是税前债务成本</li><li>t是税率</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>得到了每一个个别资本成本（普通股，优先股，长期借款，长期债券）的值后，我们接下来就需要确认各个资本的权重，然后就可以计算出加权平均资本成本（WACC）了。</p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 资本成本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资本成本和权益成本</title>
      <link href="/2018/07/27/cost-of-capital-and-equity/"/>
      <url>/2018/07/27/cost-of-capital-and-equity/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a>   <h2 id="资本成本的意义"><a href="#资本成本的意义" class="headerlink" title="资本成本的意义"></a>资本成本的意义</h2><p>一个企业需要正常运营，就需要资本。那么企业的资本一般从哪里来的呢？  </p><p>一般来说，企业的资本，要么是从外面借的，要么就是股东投的。<br>我们通过资产负债表来看的话，大概有这么几个资本来源：  </p><ul><li>长期负债</li><li>优先股东投资</li><li>普通股东投资  </li></ul><blockquote><p>资本和资金：资金包括短期和长期资金，长期资金一般被称为资本。  </p></blockquote><p>都说天下没有免费的午餐。资本如果是从外面借的，那么债权人是需要向企业收取利息的。<br>资本如果是股东投的，那么股东对自己的投资也是有期望的，因为股东是有机会成本的。 </p><blockquote><p>一般来说，股东的机会成本就是企业所在行业的平均投资收益率。</p></blockquote><p>这两种成本作用到一起，就可以得到公司使用这些资本的代价，也就是公司的资本成本。很显然，如果公司的收益比资本成本还低的话，公司就是在做赔本买卖了。  </p><blockquote><p>公司投资所应获得的最低回报率叫做 hurdle rate</p></blockquote><p>资本成本的意义就在这里。知道了资本成本以后，结合投资的预期收益就可以决定是否要进行投资了。  </p><h2 id="权益成本"><a href="#权益成本" class="headerlink" title="权益成本"></a>权益成本</h2><p>权益成本(Cost of Equity)，包括普通股和优先股成本。</p><h3 id="什么是优先股和普通股"><a href="#什么是优先股和普通股" class="headerlink" title="什么是优先股和普通股"></a>什么是优先股和普通股</h3><p>这两个的区别主要体现在股利的发放数目和发放日期上。 </p><p>优先股（Preferred Stock）有优先接受股利的权利，优先股的股利会定期发放，并且数额固定。从这个层面来看的话，优先股其实就是一项永续年金。  </p><p>普通股（Common Stock）股利的发放日期不定，数量也不确定，也就是说，能不能收到股利，全看上市公司董事会的心情。中国多数的上市公司都是不发放股利的。  </p><h3 id="优先股成本的计算"><a href="#优先股成本的计算" class="headerlink" title="优先股成本的计算"></a>优先股成本的计算</h3><p>我们知道，投资一个股票，获利有两种方式，一种是收股利，一种是价差买卖。而优先股在交易方面，只能通过公司赎回，或者转成普通股（能不能转需要根据公司发行优先股的时候来确定）。<br>所以，优先股就可以被看做是一个永续年金。  </p><p>永续年金折成现值的计算公式我们前面学过：<br><img src="http://www.doublure.cn/blog/180727/je2fLLkEKG.png?imageslim" alt="mark"></p><p>在优先股股利固定，也就是g=0，年金永续，也就是n趋向于无穷大，pmt也就是D，因此可以得到：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pv</span> = D/kp</span><br></pre></td></tr></table></figure><p>其中D是每年能领到的股利，pv就是优先股的发行价格，这样我们就能计算出kp，也就是优先股的成本。  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kp</span> = D/pv</span><br></pre></td></tr></table></figure><p>也就是说，发行价越高，优先股的成本越低。  </p><blockquote><p>在中国，发行的优先股并不多。  </p></blockquote><h3 id="普通股的成本计算"><a href="#普通股的成本计算" class="headerlink" title="普通股的成本计算"></a>普通股的成本计算</h3><p>前面说过，普通股的资产回报有两种方式：股利和交易。于是，也对应了两种计算普通股成本的方式。  </p><ol><li>股利折现法（DDM）</li></ol><p>这里需要有几个假设：</p><ul><li>每年都有股利</li><li>股利每年都以g的增长率增长</li></ul><p>于是和上面的优先股的年金计算方式类似，可以得到普通股的现值公式：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pv = D1/(<span class="name">ks-g</span>)=D0*(<span class="number">1</span>+g)/(<span class="name">ks-g</span>)</span><br></pre></td></tr></table></figure></p><p>再稍作运算，就可以得到：   </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ks</span>=D1/pv +g</span><br></pre></td></tr></table></figure><ol start="2"><li>资本定价法</li></ol><p>这个也就是传说中的CAPM法，这个方法算是奠定了现代财务分析的基础。  </p><p>简单点来讲，CAPM法就是通过股票与大盘走势的对比，通过一个风险因子（β），大概估出一个股价的增长率。  </p><p>怎么求β就够讲半天了，因此在这里先讲结论：  </p><p><img src="http://www.doublure.cn/blog/180727/cB9f0eECJE.png?imageslim" alt="mark"></p><p>也就是说，知道了β，大盘的期望收益(Rm)，无风险收益率(Rf)，就可以求出股票的期望收益了。如果投资公司的收益达不到计算出的期望收益，股民是没有必要投资这个公司的。  </p><p>除了权益成本以外，还有一个很重要的部分，就是债务成本，这个我们后面再详细研究。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://wenku.baidu.com/view/6d8b2915e45c3b3566ec8b41.html?from=search" target="_blank" rel="noopener">https://wenku.baidu.com/view/6d8b2915e45c3b3566ec8b41.html?from=search</a>  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务分析 </tag>
            
            <tag> 资本成本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对报表进行比率分析</title>
      <link href="/2018/07/24/ratio-analysis/"/>
      <url>/2018/07/24/ratio-analysis/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a>    <h2 id="什么是比率分析？"><a href="#什么是比率分析？" class="headerlink" title="什么是比率分析？"></a>什么是比率分析？</h2><p>前面的三张报表，把一个企业从资本，盈利能力，以及风险的角度进行剖析，展示了一个企业的现状。  </p><p>拿当然，仅仅看到报表里的绝对值数字是不够的，我们还要分析这些数字意味着什么，这个时候就要进行比率分析。  </p><p>所谓比率分析，其实就是分析各个财务数字之间的比率（ratio）关系。通过对比一家公司同一个比率指标在不同时期的表现，或者对比一家公司的某个比率指标与整个行业平均值，就可以判断出这家公司的财务和经营状况。  </p><p>另外，需要注意的是，<strong>单单比较某一个比率是没有意义的</strong>，<strong>需要将多个比率结合起来对比才能做出正确的判断</strong>。  </p><h2 id="比率有哪些分类？"><a href="#比率有哪些分类？" class="headerlink" title="比率有哪些分类？"></a>比率有哪些分类？</h2><ul><li>流动性比率</li><li>盈利能力比率</li><li>营运效率比率</li><li>杠杆比率</li><li>偿债保障比率  </li></ul><h2 id="流动性比率"><a href="#流动性比率" class="headerlink" title="流动性比率"></a>流动性比率</h2><h3 id="流动性"><a href="#流动性" class="headerlink" title="流动性"></a>流动性</h3><p>流动性，基本可以理解为资产变为现金的速度。<br>一个企业资产变为现金的速度越快，其流动性就越快。<br>那一个企业哪些资产容易变成现金啊？前面我们说过，流动资产是最容易变成现金的。并且，在流动资产里各项的排序，也是按照其变成现金的先后顺序来的–货币资金本身就是现金，存货要生产出来卖掉，才有可能变成现金。  </p><h3 id="流动比"><a href="#流动比" class="headerlink" title="流动比"></a>流动比</h3><p>一般来说，流动资产转化成现金后，多数情况下是用来偿还流动负债。<br>因此，我们可以用流动资产除以流动负债来得到流动比。  </p><p><code>流动比率=流动资产/流动负债</code></p><blockquote><p>流动比： Current Ratio  </p></blockquote><p>显然,流动比越高，偿债能力越强。像苹果这种公司有450亿美金现金在账面上的公司，是几乎不用担心他换不上账的（当然，苹果公司也有很多流动负债）  </p><h3 id="速动比"><a href="#速动比" class="headerlink" title="速动比"></a>速动比</h3><p>上面说过，流动资产里最不容易变成现金的是存货。存货先要经过生产，销售环节，才有可能变成应收或者货币资金。更何况，存货很有可能因为市场环境或者公司策略的原因，要很长时间才能被销售掉。<br>所以，把存货从流动资产中拿走，用剩下的流动资产除以流动负债，就得到的速动比。  </p><p><code>速动比=（流动资产-存货）/流动负债</code><br>同样，速动比越高，代表公司资产的流动性越强。  </p><h2 id="盈利能力比率"><a href="#盈利能力比率" class="headerlink" title="盈利能力比率"></a>盈利能力比率</h2><p>盈利能力是对利润表进行的分析。</p><h3 id="毛利"><a href="#毛利" class="headerlink" title="毛利"></a>毛利</h3><p><code>毛利=(营业收入-营业成本)/营业收入</code>  </p><h3 id="净利率"><a href="#净利率" class="headerlink" title="净利率"></a>净利率</h3><p><code>净利率= 净利润/营业收入</code><br>当然，净利率越高越好。但是呢，我们前面说过，净利润高不一定是真金白银，有可能是公允价值高，所以不一定能完全说明问题。因此，考察营业利率也很必要。  </p><h3 id="营业利率"><a href="#营业利率" class="headerlink" title="营业利率"></a>营业利率</h3><p><code>营业利率=营业利润/营业收入</code>  </p><p>这个指标越高，就说明营业活动收益越高</p><h3 id="总资产报酬率"><a href="#总资产报酬率" class="headerlink" title="总资产报酬率"></a>总资产报酬率</h3><p>又被称为ROA，代表的是单位资产所能取得的利润回报<br><code>ROA=净利润/总资产</code></p><h3 id="净资产报酬率"><a href="#净资产报酬率" class="headerlink" title="净资产报酬率"></a>净资产报酬率</h3><p>又被称为ROE，代表的是单位净资产（总资产-负债），也就是单位股东权益所能获得的利润回报。<br><code>ROE=净利润/股东权益</code></p><h2 id="营运效率比率"><a href="#营运效率比率" class="headerlink" title="营运效率比率"></a>营运效率比率</h2><p>基本上可以这么理解，营运效率指的就是公司的各种资源的效率，也就是周转速度。周转的越快，代表营运效率是越高的。  </p><h3 id="应收账款周转率"><a href="#应收账款周转率" class="headerlink" title="应收账款周转率"></a>应收账款周转率</h3><p>基本上来说，这就是企业在实际运营过程中最关心的周转率之一。<br>应收账款代表的是企业的赊销，这个数字越低，企业坏账的风险也会越低。<br>应收账款周转率的公式如下： </p><p><code>应收账款周转率=营业收入/应收账款</code>  </p><blockquote><p>我们看到，这个比率实际上是把利润表和资产负债表的相应数字的结合。然而，利润表反映的是一段时期之内的表现，而资产负债表反映的是某个时间节点的表现。因此，为了统一，应收账款需要使用期初和期末的应收账款的平均值。  </p></blockquote><p>应收账款周转率代表一年之内应收账款的周转次数。于是，用一年的天数，除以应收账款周转率，便可以得到平均账期。  </p><h3 id="存货周转率"><a href="#存货周转率" class="headerlink" title="存货周转率"></a>存货周转率</h3><p>代表一年之内存货的周转次数。  </p><p><code>存货周转率=营业成本/存货</code>  </p><p>同样的，在这个公式里的存货需要使用期初和期末的平均数。  </p><h3 id="固定资产周转率"><a href="#固定资产周转率" class="headerlink" title="固定资产周转率"></a>固定资产周转率</h3><p>代表单位固定资产所能产生的营业收入。  </p><p><code>固定资产周转率=营业收入/固定资产</code></p><h3 id="总资产周转率"><a href="#总资产周转率" class="headerlink" title="总资产周转率"></a>总资产周转率</h3><p>代表单位资产所能产生的营业收入。这个数值当然是越高越好。 </p><p><code>总资产周转率=营业收入/总资产</code>  </p><blockquote><p>不要忘记使用期初和期末的平均值  </p></blockquote><h3 id="重新审视ROA"><a href="#重新审视ROA" class="headerlink" title="重新审视ROA"></a>重新审视ROA</h3><p>有了上面这些比率，我们就可以重新审视ROA了。  </p><p><img src="http://www.doublure.cn/blog/180723/L91ia6F3gj.png?imageslim" alt="mark"></p><p>也就是说，总资产报酬率等于利润率与总资产周转率的乘积。  </p><p>这也就可以解释提高资产报酬率的两种方式：提高利润率(比如生产高端产品)，或者加快资产周转(薄利多销)。  </p><h2 id="杠杆比率"><a href="#杠杆比率" class="headerlink" title="杠杆比率"></a>杠杆比率</h2><p>一个公司在发展的过程中，必不可少需要使用杠杆。看看15年股灾的时候证监会去杠杆引起了多大的震动，就知道杠杆比率有多重要。  </p><h3 id="总负债比"><a href="#总负债比" class="headerlink" title="总负债比"></a>总负债比</h3><p>资产负债表的右边，是负债和股东权益，分别代表了债主和股东的利益。因为企业在还完债之后才可以对股东进行分红，因此很有必要考察企业的负债比。 </p><p><code>总负债比=负债/总资产</code>  </p><h3 id="权益乘数"><a href="#权益乘数" class="headerlink" title="权益乘数"></a>权益乘数</h3><p>从另外一个方面显示杠杆比以及负债比。 </p><p><code>权益乘数=总资产/股东权益</code>  </p><p>权益乘数越高，就代表资产中股东权益的比例越小，也就是负债的比例越高，财务风险越大。  </p><h2 id="偿债保障比率"><a href="#偿债保障比率" class="headerlink" title="偿债保障比率"></a>偿债保障比率</h2><p>这个比率和流动性比率相仿，表示的都是偿债能力。  </p><h3 id="利息保障倍数"><a href="#利息保障倍数" class="headerlink" title="利息保障倍数"></a>利息保障倍数</h3><p>使用息税前利润(EBIT)与利息的比值来表示公司偿还利息的能力。  </p><p><code>利息保障倍数=EBIT/利息</code></p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 报表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>财务报表之现金流</title>
      <link href="/2018/07/13/cash-flow/"/>
      <url>/2018/07/13/cash-flow/</url>
      <content type="html"><![CDATA[<p>​     </p><a id="more"></a><h2 id="为什么需要现金流量表？"><a href="#为什么需要现金流量表？" class="headerlink" title="为什么需要现金流量表？"></a>为什么需要现金流量表？</h2><p>在研究利润表的时候我们说过，利润高并不等于现金多。<br>举个最简单的例子，营业收入高，说明产品卖出去的多，但是，产品卖出去的多不代表能立刻收回账来。收回账来也不一定收回的是现金，还有可能是6个月的承兑。  </p><p>然而，一个企业在运营的时候需要花现金的地方简直太多了。企业每个月都会要付出利息，总不能用银行承兑来抵利息吧？就算企业可以赊账购买原料，但不可能所有供应商都愿意让企业赊账吧？  </p><p>再举个更简单的例子：多数销售人员在大学刚毕业的时候，没攒下什么钱，可偏偏要经常出差，所有费用都要自己先垫付，然后找公司报销。要报销的钱，从财务上来看，都是应收账款。要报销的数额越大，就相当于公司占用了越多的个人现金。如果个人积蓄不够雄厚，过几个月可能就没有钱付房租了。  </p><p>类比过来，企业的经营也是如此。资产负债表能看到企业的家底，利润表能看到企业到底赚不赚钱，现金流量表则是从运营风险的角度来看企业的运转是否正常。  </p><h2 id="现金流量表是怎么组织的？"><a href="#现金流量表是怎么组织的？" class="headerlink" title="现金流量表是怎么组织的？"></a>现金流量表是怎么组织的？</h2><p>一个基本的概念是，一个企业始终在进行经营，投资和融资活动。<br>那么，把每一种活动的每一笔现金流入和流出都记录下来，最后再根据企业活动类型（经营，投资，融资）以及流向（流入，流出）来进行分类，就可以得到一张现金流量表。  </p><p>没错，现金流量表就是把现金（注意一定是现金）的流水账，分分类，然后用类似数据透视表（Pivot Table）的技术进行汇总。</p><h2 id="经营，投资和融资各包括什么活动？"><a href="#经营，投资和融资各包括什么活动？" class="headerlink" title="经营，投资和融资各包括什么活动？"></a>经营，投资和融资各包括什么活动？</h2><p>大致上，这三项活动涉及的现金流入流出可以这样来划分：  </p><h4 id="经营活动"><a href="#经营活动" class="headerlink" title="经营活动"></a>经营活动</h4><ul><li>流入<ul><li>销售</li><li>税收（退税）</li></ul></li><li>流出<ul><li>采购</li><li>税收（交税）</li><li>人工</li></ul></li></ul><h4 id="投资活动"><a href="#投资活动" class="headerlink" title="投资活动"></a>投资活动</h4><ul><li>对内投资<ul><li>流入<ul><li>处置资产 </li></ul></li><li>流出<ul><li>购建固定资产（注意购买固定资产是投资，不是经营活动）</li></ul></li></ul></li><li>对外投资<ul><li>流入<ul><li>处置收益</li></ul></li><li>流出<ul><li>投资</li></ul></li></ul></li></ul><h4 id="融资活动"><a href="#融资活动" class="headerlink" title="融资活动"></a>融资活动</h4><ul><li>债务融资<ul><li>流入<ul><li>借款，融入资本 </li></ul></li><li>流出<ul><li>还本付息</li></ul></li></ul></li><li>股权融资<ul><li>流入<ul><li>融入资金</li></ul></li><li>流出<ul><li>分红</li></ul></li></ul></li></ul><h2 id="现金流量表与资产负债表的关系是什么？"><a href="#现金流量表与资产负债表的关系是什么？" class="headerlink" title="现金流量表与资产负债表的关系是什么？"></a>现金流量表与资产负债表的关系是什么？</h2><p>现金流量表展示的也是某个时间段内，资产负债表中货币资金的变化。也就是说，现金流量表完全是在详细的解释货币资金发生了什么变化，这些变化是由什么造成的。  </p><p>再把利润表也拉进来，我们就可以得到这三张报表之间最直截了当的关系：<br>资产负债表是主体，利润表和现金流量表从盈利能力以及企业风险的角度来更深层次揭示企业的财务运转情况。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 报表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>财务报表之利润表</title>
      <link href="/2018/07/13/income-statement/"/>
      <url>/2018/07/13/income-statement/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>前面我们说过，资产负债表是反映一个企业家底的表格。既然如此，为了更深入地了解企业，很自然有一个问题就冒了出来：  </p><blockquote><p>企业的钱都是从哪里赚来的？  </p></blockquote><p>资产负债表的股东权益里有一项叫做未分配利润，上面这个问题其实就是问：未分配利润是怎么来的？  </p><p>所以，我们需要深入研究一个企业的收入，以及盈利能力。利润表就是用来干这个的。  </p><h2 id="利润表是怎么做出来的"><a href="#利润表是怎么做出来的" class="headerlink" title="利润表是怎么做出来的"></a>利润表是怎么做出来的</h2><p>说白了，利润表就是收入减去各种费用得来的，这和我们平时算账差不多。  </p><p>利润表里的各项元素有下面这些：</p><h3 id="营业收入"><a href="#营业收入" class="headerlink" title="营业收入"></a>营业收入</h3><p>这个术语一看就知道是属于经营活动产生的收入。<br>这里要注意一点：营业收入是不包含增值税的。<br>具体点讲，增值税是价外税，并且是流转税，实际上最终都是由消费者承担的，所以增值税不影响最终损益。<br>也就是说，增值税在利润表中是不体现的。  </p><h3 id="营业成本"><a href="#营业成本" class="headerlink" title="营业成本"></a>营业成本</h3><p>生产或者营业所产生的成本。产生成本的项目很多，也可以分成两种：  </p><ul><li>可变成本<br>简单点理解，可变成本就是跟随产品产量变化的成本。<br>例如，生产一台电脑需要很多芯片，电脑生产的越多，就需要越多芯片。如果不生产电脑，就不需要付芯片的钱。<br>在上面这个例子里，芯片就属于电脑生产的可变成本。  </li><li>固定成本<br>简单点理解，公司生产或不生产，固定成本就在那里，不多不少。<br>举个例子，为了生产电脑需要购买流水线，价格1000万，折旧5年。那么不管公司生不生产电脑，固定资产折旧的成本每年都是200万（按照线性折旧来计算）。<br>假设一条流水线每年能生产1万台电脑，每一天电脑的芯片成本1000元（不考虑其他可变成本），那么公司出来的电脑需要卖至少要卖200/1+1000=1200块才能保本。但是在某些极端情况下，如果市场下游需求不好，很有可能1100块也可以卖，每台电脑还可以赚100块来抵消一部分固定成本。</li></ul><h3 id="营业税金及附加"><a href="#营业税金及附加" class="headerlink" title="营业税金及附加"></a>营业税金及附加</h3><p>在中国有一个特色税种，叫做营业税。<br>营业税是一种价内流转税，以前一般都使用在服务业。<br>营业税的特点是：企业在经营，不管有没有赚钱，都得交营业税。<br>不过16年5月国家全面实施了营改增，营业税算是退出历史舞台了，这个科目也变成了税金及附加。<br>附加又指的是什么呢？<br>调整过后的附加包括：消费税、城市维护建设税、资源税、教育费附加及房产税、土地使用税、车船使用税、印花税等</p><h3 id="营业费用"><a href="#营业费用" class="headerlink" title="营业费用"></a>营业费用</h3><p>在生产和销售过程中所产生的费用。一般包括：  </p><ul><li>清关报关费用</li><li>物流费用</li><li>货物保险</li><li>由销售活动所带来的费用，如销售人员的差旅费用，工资等</li><li>广告费</li></ul><h3 id="管理费用"><a href="#管理费用" class="headerlink" title="管理费用"></a>管理费用</h3><p>与企业的管理环节相关的费用。包括：  </p><ul><li>管理部门职工工资</li><li>管理人员的差旅费用</li><li>研发费用</li><li>咨询费</li><li>公司办公楼的折旧</li></ul><h3 id="财务费用"><a href="#财务费用" class="headerlink" title="财务费用"></a>财务费用</h3><p>企业经营过程中筹资或者银行存款所发生的费用，包括：</p><ul><li>利息支出</li><li>利息收入</li><li>手续费</li><li>汇兑损益</li></ul><p>上面的这些项目，是企业基本经营和筹资方面所产生的收益部分，当然，其他因素也能影响企业的利润，这些又包括：</p><h3 id="投资收益"><a href="#投资收益" class="headerlink" title="投资收益"></a>投资收益</h3><p>投资收益是企业营业利润当中的一部分，指的是企业投资所产生的收益，包括股利，分红等等。  </p><h3 id="资产减值损失"><a href="#资产减值损失" class="headerlink" title="资产减值损失"></a>资产减值损失</h3><p>如果资产相对于历史成本发生减值，就需要把减值也记录在利润表里。<br>当然，如果资产升值的话，利润表是不做记录的。  </p><h3 id="公允价值变动收益"><a href="#公允价值变动收益" class="headerlink" title="公允价值变动收益"></a>公允价值变动收益</h3><p>对于金融资产来说，是有公允价值(Fair Value)的，如果企业所拥有的金融或者房地产资产比上一期末有变化，也需要把变化的值记录下来。  </p><p>有了上面这些信息，我们就可以得到企业的营业利润了。  </p><h3 id="营业利润"><a href="#营业利润" class="headerlink" title="营业利润"></a>营业利润</h3><p>通过简单的数学计算就可以得到：  </p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">营业利润</span>=<span class="string">营业收入-营业成本-税金及附加-营业费用-管理费用-财务费用+投资收益-资产减值损失+公允价值变动收益</span></span><br></pre></td></tr></table></figure><p>除了正常的营业利润，企业在一个周期内可能会有一些其他收入或者支出，而这些收入或支出不一定是由于营业带来的。</p><h3 id="营业外收入"><a href="#营业外收入" class="headerlink" title="营业外收入"></a>营业外收入</h3><p>企业在营业范围以外所获得的收入，例如： </p><ul><li>获得政府补贴</li><li>出售无形资产（专利，商标等）</li><li>处置固定资产收入</li><li>罚款收入</li></ul><h3 id="营业外支出"><a href="#营业外支出" class="headerlink" title="营业外支出"></a>营业外支出</h3><p>与上面营业外收入对应，指企业在经营范围以外的支出，例如：</p><ul><li>处置固定资产损失</li><li>公益捐款</li><li>非常损失（例如火灾等等）</li><li>固定资产盘亏</li></ul><p>有了营业外的收入和支出，我们就可以再进一步，获得企业利润总额了。  </p><h3 id="利润总额"><a href="#利润总额" class="headerlink" title="利润总额"></a>利润总额</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">利润总额</span>=<span class="string">营业利润+营业外收入-营业外支出</span></span><br></pre></td></tr></table></figure><h3 id="所得税费用"><a href="#所得税费用" class="headerlink" title="所得税费用"></a>所得税费用</h3><p>这个不需要解释，赚了钱，还能不交税？中国企业所得税的税率是25%，老老实实交税吧！<br>这里要注意一点：所得税的税率是25%，并不代表拿到手里的钱一定是利润总额的75%</p><blockquote><p>应税所得是税法规定的，可能会高于利润总额  </p></blockquote><h3 id="净利润"><a href="#净利润" class="headerlink" title="净利润"></a>净利润</h3><p>交完税了，剩下的就是净利润了。<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">净利润</span>=<span class="string">利润总额-所得税费用</span></span><br></pre></td></tr></table></figure></p><h2 id="利润不等于现金流"><a href="#利润不等于现金流" class="headerlink" title="利润不等于现金流"></a>利润不等于现金流</h2><p>正常来看，在企业的资产负债表上的股东权益部分，是可以体现利润情况的。如果只看一个总数，利润很高，会很亮眼。但是，这些利润是从哪来的？这些高利润是否能够持久维持？这两个问题仅仅看一个数字是看不出来的。<br>所以，我们需要有一张利润表，把企业各个方面的盈利能力一一量化，这样我们就会对企业来钱的能力有更深刻的认识。  </p><p>但是，利润高和有钱不是一回事！  </p><p>我们看到前面，利润高的原因可能有很多：  </p><ul><li>营业收入高</li><li>一般费用低</li><li>公允价值变动收益多</li><li>投资收益多</li></ul><p>这里面：  </p><ul><li>公允价值变动收益可能根本不会立刻带来现金</li><li>营业收入高，不代表所有账款都已经收回来</li></ul><p>所以，光有资产负债和利润表并不能体现出企业的货币资金的情况，这个时候就需要一张现金流量表了。  </p><h2 id="利润表是一个阶段企业利润的显示"><a href="#利润表是一个阶段企业利润的显示" class="headerlink" title="利润表是一个阶段企业利润的显示"></a>利润表是一个阶段企业利润的显示</h2><p>我们前面说过，资产负债表显示的是某一个特定的时间点，企业所拥有的资产情况。<br>而利润表不同，利润表表示的是一个时间段内（通常是指1个季度，半年，3个季度，全年），公司的盈利情况。</p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 报表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>财务报表之资产负债表</title>
      <link href="/2018/07/04/balance-sheet/"/>
      <url>/2018/07/04/balance-sheet/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><h2 id="企业的主要行为是什么？"><a href="#企业的主要行为是什么？" class="headerlink" title="企业的主要行为是什么？"></a>企业的主要行为是什么？</h2><ul><li>经营</li><li>投资</li><li>融资  </li></ul><h2 id="资产负债表是什么？"><a href="#资产负债表是什么？" class="headerlink" title="资产负债表是什么？"></a>资产负债表是什么？</h2><p>反映一个企业所拥有的资产的，也就是企业家底的一个表格。<br>资产就是是可以货币表示的东西<br>资产仅仅是企业资源的一部分  </p><h2 id="资产负债表由哪些构成？"><a href="#资产负债表由哪些构成？" class="headerlink" title="资产负债表由哪些构成？"></a>资产负债表由哪些构成？</h2><h3 id="资产"><a href="#资产" class="headerlink" title="资产"></a>资产</h3><p>从流动性上来看，两大类，6小类  </p><h4 id="流动资产"><a href="#流动资产" class="headerlink" title="流动资产"></a>流动资产</h4><p>一般指一年（或者一个经营周期）内可以转化成现金的资产<br>流动资产包括三项主要的资产</p><ol><li>货币资金</li><li>债券<ul><li>应收账款</li><li>预付账款</li></ul></li><li>存货</li></ol><h4 id="非流动资产"><a href="#非流动资产" class="headerlink" title="非流动资产"></a>非流动资产</h4><p>一般指一年（一个周期）以上才可以转化成现金的资产</p><ol><li>长期投资<br> 比较重要的是长期股权投资，经常用来做文章</li><li>固定资产<ul><li>固定资产</li><li>在建工程</li><li>固定资产清理</li><li>投资性房地产</li></ul></li><li>无形资产以及其他非流动资产<ul><li>无形资产</li><li>开发支出</li><li>商业信誉等</li></ul></li></ol><p>从对利润的贡献方式来看的话，也分两类：  </p><h4 id="经营资产"><a href="#经营资产" class="headerlink" title="经营资产"></a>经营资产</h4><ul><li>货币</li><li>债券</li><li>存货</li><li>固定资产</li><li>无形资产<h4 id="投资资产"><a href="#投资资产" class="headerlink" title="投资资产"></a>投资资产</h4></li><li>可供出售金融资产</li><li>持有至到期的投资</li><li>长期股权投资  </li></ul><p>资产负债表的右边，就是写明了资产的归属，资产的归属有两种人：  </p><ul><li>债权人</li><li>股东</li></ul><h3 id="负债"><a href="#负债" class="headerlink" title="负债"></a>负债</h3><p>流动负债: 企业在一年（一个周期）之内必须要支付的负债</p><ul><li>短期借款</li><li>应付账款</li><li>预收账款   </li></ul><p>非流动负债：一年以后才需要偿还的负债  </p><ul><li>长期借款</li><li>长期应付款</li><li>其他非流动资产</li></ul><h3 id="股东权益"><a href="#股东权益" class="headerlink" title="股东权益"></a>股东权益</h3><ul><li>实收资本/股本<br>股本是针对上市公司而言的，普通的公司叫实收资本。<br>在中国就是注册资本，股本的总额体现出了公司对外承担的法律责任的上限  </li><li>资本公积<br>股东入资导致超过股本，多出来的部分就放到资本公积里</li><li>盈余公积<br>中国规定企业10%的利润一定要存到盈余公积里    </li><li>未分配利润<br>公司利润先留10%到盈余公积，然后剩下的部分再分红，最后还剩下的部分就叫未分配利润   </li></ul><h2 id="一个守恒定律"><a href="#一个守恒定律" class="headerlink" title="一个守恒定律"></a>一个守恒定律</h2><p>资产= 负债+股东权益，放之四海而皆准  </p><p>资产形态的变化，不影响负债和股东权益的变化。也就是说，用现金投资了固定资产，变化的只是资产部分的内部，而负债和股东权益是不会变的。<br>如果资产小于负债，导致股东权益为负，就是资不抵债  </p><h2 id="资产负债表意味着什么？"><a href="#资产负债表意味着什么？" class="headerlink" title="资产负债表意味着什么？"></a>资产负债表意味着什么？</h2><p>资产负债表显示的只是某个特定时刻，例如年末或者季度末，公司整体的家底。但在这一年里发生了什么？资产负债表上是看不出来的。<br>结果导向，是资产负债表最大的特点。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 报表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>连续复利的计算</title>
      <link href="/2018/06/25/continuous-compounding/"/>
      <url>/2018/06/25/continuous-compounding/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>我们前面说过，时间是投资的朋友，其实也就是说，复利可以生成更多的终值。<br>如果现在银行定期的年存款利率为5%，并且你计划存12000块到银行存款。现在有两家银行可选，一家银行半年结一次息，另外一家银行3个月结一次息。如果想到年底获得最大的终值，应该怎么选呢？  </p><p>前面我们说过，终值的计算公式是这样子的：  </p><p><img src="http://www.doublure.cn/blog/180625/jf788E778B.png?imageslim" alt="mark">  </p><ul><li>其中i是年华利率  </li><li>n是以年计算的期数</li></ul><p>如果把一年分成m期，那么每期的收益率就变成了i/m,总共的期数就变成了nm。上面的公式就变成了：  </p><p><img src="http://www.doublure.cn/blog/180625/2iji6i1lll.png?imageslim" alt="mark">  </p><p>假设银行允许你极限操作，每年可以分成的期数m允许为无穷大，我们队上面公式求个极限：  </p><p><img src="http://www.doublure.cn/blog/180625/5Dgaj3dh2L.png?imageslim" alt="mark"></p><p>也就是说，在每年可以分成无穷多期的情况下，每年的收益可以逼近<code>e^i-1</code>  </p><p>最后，我们用Excel来模拟一下一年分成多期的情况。下面这个图列出了每年分的期数，以及对应的终值。可以看得出来，期数越多，终值是越高的。不过貌似分52期和分一期最后只差了0.1%，资金量小的时候，差别不大，但当资金量大的时候，这0.1%还是很可观的。<br><img src="http://www.doublure.cn/blog/180625/Ji48B9L63K.png?imageslim" alt="mark">  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>e^i-1</code>这个极限值要记住</li></ul>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>递增年金的终值和现值</title>
      <link href="/2018/06/25/growing-annuities/"/>
      <url>/2018/06/25/growing-annuities/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>上一篇文章中，我们探讨了货币的时间价值，以及年金在每期数额相等的情况下，所对应的现值和终值。<br>实际情况中，我们也会经常遇到年金不断增长的情况。比如说下面这个例子：<br>现在有一笔钱要存入银行，存款利率为5%。你准备在未来6年每年提出10000块钱用作孩子的学费。然而，学费以每年3%的速度增长。那么，你现在需要存入多少钱才可以？  </p><h2 id="传统数学方法计算现值"><a href="#传统数学方法计算现值" class="headerlink" title="传统数学方法计算现值"></a>传统数学方法计算现值</h2><p>我们假设年金每年的增长率为g(上面例子为3%)<br>投资利率为i(上面例子为5%)<br>起始年金为pmt(上面例子为10000)<br>期数为n(上面例子为6)  </p><p>在这种情况下，年金的示意图为：  </p><p><img src="http://www.doublure.cn/blog/180625/H0jej0L3cF.png?imageslim" alt="mark">  </p><p>每年年金对应的PV计算如下：  </p><p><img src="http://www.doublure.cn/blog/180625/e9Ih6LEaKc.png?imageslim" alt="mark">  </p><p>把每年的PV相加，利用等比数列的求和公式，就可以得到总的PV  </p><p><img src="http://www.doublure.cn/blog/180625/GH3ikaKKAC.png?imageslim" alt="mark">  </p><p>用Excel来计算如下：<br><img src="http://www.doublure.cn/blog/180625/emBhmj9cmD.png?imageslim" alt="mark"></p><h2 id="另外一种思路"><a href="#另外一种思路" class="headerlink" title="另外一种思路"></a>另外一种思路</h2><p>这个公式看起来也很复杂，有没有别的思路来看待这个问题呢？   </p><p>如果我们先不考虑年金，只计算单笔资金的情况：  </p><p>n年后，单笔资金的FV为 <code>PV(1+i)^n</code><br>n年后，资金购买力下降（可以理解成通货膨胀），单笔资金因为通货膨胀所造成的贬值因子为：<code>(1+g&gt;^n</code><br>n年后，资金的实际购买力为：<code>PV(1+i)^n/(1+g)^n</code><br>这个公式看起来很眼熟，把他和正常的<code>FV=PV(1+i)^n</code>相比，就相当于是实际的利率为：  </p><p><img src="http://www.doublure.cn/blog/180625/J61j01di3f.png?imageslim" alt="mark"></p><blockquote><p>题外话：如果你的资产增长率低于通货膨胀率的话，那你的资产增长的实际利率就变成负值，被割韭菜是不可避免了。</p></blockquote><h2 id="使用PV函数计算"><a href="#使用PV函数计算" class="headerlink" title="使用PV函数计算"></a>使用PV函数计算</h2><p>有了实际利率，我们就可以使用Excel自带的PV函数来计算现值了。在计算的时候，还有一点要注意：我们在案例中的PMT是从第一期开始计算的，需要把它修正为第0期。  </p><p>怎么修正呢？直接用第一期的PMT除1+g即可。  </p><p>我们把上面的参数带入到Excel中，就可以直接用PV计算出结果。  </p><p><img src="http://www.doublure.cn/blog/180625/LHi2Jj197m.png?imageslim" alt="mark"></p><h2 id="计算终值"><a href="#计算终值" class="headerlink" title="计算终值"></a>计算终值</h2><p>我们有了上面的现值公式，又知道了现值和终值的关系，所以，直接把现值乘上(1+i)^n即可。<br>于是，终值的公式就成为：  </p><p><img src="http://www.doublure.cn/blog/180625/CIeEEdjg62.png?imageslim" alt="mark">  </p><p>这里要注意的是，不能使用上述计算PV的参数来计算FV。最好的方法，还是把上面的PV计算出来之后，再乘<code>(1+i)^n</code><br><img src="http://www.doublure.cn/blog/180625/A7EAK0ea5h.png?imageslim" alt="mark">  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>递增年金的概念，以及计算其现值和终值的方法</li></ul>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>货币的时间价值</title>
      <link href="/2018/06/24/time-value-of-money/"/>
      <url>/2018/06/24/time-value-of-money/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>我们在不少地方应该都听说过，时间是投资的朋友。金融学里一个很重要的思想，就是钱生钱。<br>简单的说，今天的100块，和一年后的100块，从价值上来说是不一样的。因为，今天我可以用100块去投资，哪怕是投风险最低，收益最低的国债，明年怎么也能拿到103块左右。  </p><p>从这个例子来说，现在这个时间点，这100块钱就值100块，这个称作现值。一年后，变成了103块，这103块就是一年以后的终值。  </p><blockquote><p>现值：PV Present Value<br>终值：FV Future Value  </p></blockquote><h2 id="现值和终值的关系"><a href="#现值和终值的关系" class="headerlink" title="现值和终值的关系"></a>现值和终值的关系</h2><p>对于一笔数额为m的投资，如果采用复利的方式，每年利率为i，如何计算n年以后的终值呢？  </p><ul><li>第一年的FV为：<code>m(1+i)</code>  </li><li>第二年的FV为：<code>m(1+i)(1+i)=m(1+i)^2</code></li><li>…</li><li>第n年的FV为：<code>m(1+i)^n</code>  </li></ul><p>也就是说，<code>FV=PV(1+i)^n</code>。这样我们就得到了一个现值PV和终值FV的计算公式，就可以利用现值PV，计算终值FV，或者用终值FV来计算现值PV。  </p><h2 id="用Excel计算现值和终值"><a href="#用Excel计算现值和终值" class="headerlink" title="用Excel计算现值和终值"></a>用Excel计算现值和终值</h2><p>Excel作为金融学的好基友，提供了计算现值PV和终值FV的函数。<br>内置的终值函数FV截图如下，有5个参数：  </p><p><img src="http://www.doublure.cn/blog/180624/DhI8l8da84.png?imageslim" alt="mark">  </p><ul><li>Rate表示每一期的利率</li><li>Nper表示一共的期数</li><li>Pmt表示每期存入或支出的资金数量，在单个资金的计算里，设置为0  </li><li>Pv表示资金的现值</li><li>Type与Pmt相关，在这里设置为默认为0  </li></ul><p>举个例子：<br>现在每个月工资10000元，假设工资每年增长7%，那么20年以后，你的工资会是多少钱？  </p><p>如下图，我们直接用<code>v(0.07,20,0,-10000,0)</code>计算即可。<br>注意，上面公式的PV我们设置为-10000,因为Excel自动把PV或者FV默认为现金流出。关于正负号的问题，可以参考Quora上的<a href="https://www.quora.com/Why-does-Excel-show-the-future-value-as-a-negative-of-the-present-value" target="_blank" rel="noopener">这篇文章</a><br><img src="http://www.doublure.cn/blog/180624/AFHgKgbF68.png?imageslim" alt="mark">  </p><p>同样道理，Excel也提供了一个现值函数PV，用来求给定终值FV对应的现值。<br>我们看，PV函数的参数和FV函数基本差不多，用法也差不多。  </p><p><img src="http://www.doublure.cn/blog/180624/GkhcJFd9c8.png?imageslim" alt="mark">  </p><p>再举个例子：  </p><p>你准备一次性拿出一部分钱投资，如果投资利率为7%，你想要在30年后拿到100万，那么现在应该投资多少钱？ </p><p>同样道理，我们用<code>pv(0.07,30, 0,-1000000,0)</code>即可。</p><p><img src="http://www.doublure.cn/blog/180624/3fjeJDbfic.png?imageslim" alt="mark"></p><h2 id="年金的现值和终值"><a href="#年金的现值和终值" class="headerlink" title="年金的现值和终值"></a>年金的现值和终值</h2><p>上面我们接触的情况，都是单笔投资，对于一定年限的现值或者终值。<br>在现实生活中，我们也经常会遇到定期投资一定数额（存款定投）或者是定期支出一定数额（房贷车贷）这种情况。这种一定时间内一定期数的款项，被称作年金。  </p><blockquote><p>年金：Annuitites  </p></blockquote><p>下面这个图表示了一个最简单的年金示意图：每年存入100块，连续存5年。  </p><p><img src="http://www.doublure.cn/blog/180624/fFI3Lacbd4.png?imageslim" alt="mark"></p><p>上面这个年金对应的现值应该怎么计算呢？我们需要按照每一期来计算。  </p><ul><li>第一期对应的PV为<code>100/(1+i)</code></li><li>第二期对应的PV为<code>100/(1+i)^2</code></li><li>…</li><li>第五期对应的PV为<code>100/(1+i)^5</code></li></ul><p>总的现值等于上面5个PV的加和。<br>上面的步骤可以抽象成这个公式：  </p><p><img src="http://www.doublure.cn/blog/180624/DG933igB8c.png?imageslim" alt="mark">  </p><p>如果每次的<code>pmti</code>相同的话，我们可以使用等比数列求和公式来得到年金的现值：  </p><p><img src="http://www.doublure.cn/blog/180624/fdCkC53I83.png?imageslim" alt="mark">   </p><p>我们上面说过，现值和终值的关系是这样的：  </p><p><img src="http://www.doublure.cn/blog/180624/dlG91LmaKH.png?imageslim" alt="mark"></p><p>再结合上面年金现值的公式，因此年金终值的公式就成为：  </p><p><img src="http://www.doublure.cn/blog/180624/chbG0bF6l9.png?imageslim" alt="mark"></p><p>看下面这个例子：  </p><p>现在你准备给孩子在银行买一笔理财金，从明年开始，每年提取出10000块用于孩子的学费，一共6年。银行的理财收益率为5%的情况下，应该买多少？  </p><p>我们用上面现值的公式，很容易就可以得到:<br><img src="http://www.doublure.cn/blog/180624/K439kAh635.png?imageslim" alt="mark">  </p><p>再看一个例子：  </p><p>工作后，你准备每年存10000块到理财产品，年化收益率为5%，那么30年后，你会有多少钱？<br>利用年金的终值公式，我们可以计算出来。</p><p><img src="http://www.doublure.cn/blog/180624/KK1mi9mlc6.png?imageslim" alt="mark"></p><p>上面两种计算方法公式看起来很麻烦，万一记不住怎么办？  </p><p>其实我们在前面计算FV和PV时，提到过有一个PMT参数。我们在前面所讲的年金，实际上就是PMT参数。  </p><p>因此，如果要计算上面含有年金的PV，可以直接使用这个公式：  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PV(<span class="number">0.05</span>,<span class="number">6</span>,<span class="number">-10000</span>)=<span class="number">50757</span></span><br></pre></td></tr></table></figure><p>类似的，可以用FV结合PMT参数直接求年金的终值。  </p><h2 id="现值终值全家桶函数"><a href="#现值终值全家桶函数" class="headerlink" title="现值终值全家桶函数"></a>现值终值全家桶函数</h2><p>不知道大家发现没有，我们上面反复在求FV和PV，其实最终涉及到这么几个参数：  </p><ul><li>PV</li><li>FV</li><li>Rate</li><li>NPer</li><li>PMT  </li></ul><p>其实，这5个参数，知道其中任意4个，求剩下的一个，Excel都有相对应的函数。  </p><p>最常用的应该是PMT和Rate函数。  </p><p>在<a href="https://doublure.github.io/2018/06/23/excel-loan-repayment-basic/#more">这篇文章</a>中，我们计算了等额本息方法下的还款额。<br>实际上我们想一下，要求解的还款额其实就相当于是年金。现值为1500000，终值为0（想象成银行在你这存款）<br>所以，我们不需要用复杂的公式，直接用：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PMT(<span class="number">0.049</span>/<span class="number">12</span>, <span class="number">360</span>, <span class="number">-1500000</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>即可求出每个月要还款7960元。  </p><p>Rate函数，用来求给定了现值，终值，年金，和期数后，所要求的利率。<br>一个更常用的用法应该是求复合增长率。例如，如果你的公司要求业绩5年翻番，那么平均每年需要增长多少？<br>对于上面这个问题，我们直接用：  </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">RATE</span>(<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>可以得到，每年的增长率为14.87%  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现值和终值是财务分析里最最基础的概念，如果能深刻理解钱生钱这个理念的话，本篇文章的所有内容也就都不难理解了。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Excel计算还款之理论基础</title>
      <link href="/2018/06/23/excel-loan-repayment-basic/"/>
      <url>/2018/06/23/excel-loan-repayment-basic/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>新开一部分专题，来讲讲Excel在金融建模中的应用。  </p><p>计划在这个专题里，跟随经典的教材，讲一些日常生活中我们常见的可以和财务以及Excel结合的例子。一方面，可以提高自己的金融知识水平，另一方面，也可以顺手解决一些实际需求。  </p><p>今天先从还款，也就是<code>loan repayment</code>讲起。  </p><p>话说小明毕业后来到魔都，经过5年奋斗，终于省吃俭用的攒下了10万块钱。加上家里父母支持的90万，凑够了100万首付。他看中的房子标价250万，他还需要贷款150万。  </p><p>问题来了，如果小明商业贷款的利率是每年4.9%，计划30年还清，那他每个月需要还多少月供？  </p><p>在开始计算之前，我们需要弄清楚偿还贷款的两种方式：等额本金和等额本息法。  </p><blockquote><p>等额本金：Even Principal Payments<br>等额本息： Even Total Payments  </p></blockquote><h2 id="等额本金"><a href="#等额本金" class="headerlink" title="等额本金"></a>等额本金</h2><p>等额本金的概念是：每个月的还款包括两部分：本金部分和利息部分。<br>每次还款中的本金部分的数额都是相同的，而利息部分则等于<br>剩余未偿还的本金所产生的利息。<br>以上面的例子为例：  </p><ul><li>贷款总额150万，360个月偿还，每个月需要还<code>1500000/360=4167</code>元本金</li><li>第一个月本金基数为150万，所产生的利息为：<code>1500000*0.049/12=6125</code></li><li>所以第一个月的偿还总额为：<code>4167+6125=10292</code>  </li></ul><p>到了第2个月</p><ul><li>需要偿还的本金依旧是<code>4167</code>元</li><li>因为上一个月已经还了<code>4167</code>元本金，因此剩余的本金产生的利息为：<code>(1500000-4167)*0.049/12=6108</code></li><li>所以第二个月的还款总额是：<code>4167+6108=10275</code>  </li></ul><p>以此类推，一直到最后一个月。  </p><p>算一算我们就看出来了，等额本金法每个月的还款额是逐渐减少的。<br>每个月减少的数额实际上就是上个月偿还的本金额一个月所产生的利息。用上面的例子来计算，就是<code>4167*0.049/12=17</code>。  </p><p>用Excel模拟计算出来的结果如下：<br><img src="http://www.doublure.cn/blog/180623/dkK69Ajbj0.png?imageslim" alt="mark"></p><h2 id="等额本息"><a href="#等额本息" class="headerlink" title="等额本息"></a>等额本息</h2><p>等额本息的概念是：每期还款的数额是不变的。每期还款后，剩下的本金加上当期产生的利息作为一个整体继续计息。  </p><blockquote><p>这种方式就是利滚利  </p></blockquote><p>假设每期的利率为r<br>贷款金额为p</p><ul><li>第一期还款x元，剩余欠款为<code>p(1+r)-x</code></li><li>第二期还款x元，剩余欠款为<code>(p(1+r)-x)*(1+r)-x = p(1+r)^2 -x(1+r) -x</code></li><li>第三期还款x元，剩余欠款为<code>p(1+r)^3- x(1+r)^2- x(1+r) -x</code></li><li>第n期还款x元，剩余欠款为 <code>p(1+r)^n - x(1+r)^(n-1) -x(1+r)^(n-2) - ... - x(1+r) -x</code></li></ul><p>到了第n期，剩余欠款就为0了，因此 p(1+r)^n - x(1+r)^(n-1) -x(1+r)^(n-2) - … - x(1+r) -x = 0<br>利用上面这个公式，以及等比公式求和公式，我们可以推导出：  </p><p><img src="http://www.doublure.cn/blog/180623/EgJ0K132CG.png?imageslim" alt="mark">  </p><p>回到我们题目中的例子，如果采用等额本息的方法，每个月的还款额为：<code>1500000*0.049/12*(1+0.049/12)^360/((1+0.049/12)^360-1)=7691</code>    </p><p>用Excel模拟出来的结果如下：   </p><p><img src="http://www.doublure.cn/blog/180623/FKf16HDEg4.png?imageslim" alt="mark"></p><h2 id="两种方法的比较"><a href="#两种方法的比较" class="headerlink" title="两种方法的比较"></a>两种方法的比较</h2><ul><li>从实际还款总额来看的话，等额本金法比等额本息法要少。我们上面这个例子，等额本金最终所有还款额为260万，而等额本息的还款总额为286万  </li><li>从每期还款数目来看的话，等额本金法最初的单期还款数额比等额本息要高很多，初期的资金压力会比较大，但其还款金额会随着时间递减</li></ul><p>上面公式看起来都蛮复杂的，那么怎么样用Excel来计算呢？这个我们在下一节继续研究。  </p>]]></content>
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同样的Access，不一样的数据类型</title>
      <link href="/2018/06/21/Access-version-data-type/"/>
      <url>/2018/06/21/Access-version-data-type/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>最近算是和<code>ACCESS</code>彻底杠上了。  </p><p>其实我一般是不太喜欢用<code>ACCESS</code>的，因为自己不是专门做数据库的，用<code>ACCESS</code>总有一种杀鸡用牛刀的感觉。  </p><p>不过最近做一个项目，指定要用<code>ACCESS</code>。于是在自己的私人电脑上做了一个小的demo文件。<br>然而，这个文件拷贝到公司电脑上，打开时却报错了：  </p><p><img src="http://www.doublure.cn/blog/180621/FJc7mJGKb0.png?imageslim" alt="mark"></p><p>看这个报错，貌似是因为公司电脑的<code>ACCESS</code>版本不够高？查看了一下公司电脑的版本，已经是2016版了。难道还有比2016版还要高的版本？ </p><p><img src="http://www.doublure.cn/blog/180621/jhfjdHjCCk.png?imageslim" alt="mark">  </p><p>还是老套路，到<code>MSDN</code>上面搜一个报错关键词，查到<a href="https://support.microsoft.com/en-gb/help/3208802/database-you-are-trying-to-open-requires-a-newer-version-of-microsoft" target="_blank" rel="noopener">这个页面</a>，里面提到：  </p><blockquote><p>This issue occurs if you try to open a database that contains a table that uses the BigInt data type. BigInt support was added to Access 2016. BigInt appears within the table’s data type as Large Number.</p></blockquote><p>也就是说，<code>ACCESS</code>2016版里新增了一个数据类型叫<code>BigInt</code>。如果用以前的<code>ACCESS</code>版本来打开含有<code>BigInt</code>类型的文件，就会报错。   </p><p>那么问题来了，我的公司电脑已经是2016版的，里面有没有<code>Large Number</code>这个数据类型呢？看了一下，居然没有！为什么呢？</p><p><img src="http://www.doublure.cn/blog/180621/3hAfah8gC6.png?imageslim" alt="mark">  </p><p>还有一点：<code>MSDN</code>里说，如果要打开的表格里使用了<code>BigInt</code>这个类型才会报错，可是我的原始文件里也没有用到这个数据类型，为什么也会报错呢？  </p><p>这两个问题始终没有得到答案。最后的处理方式是：把私人电脑里的<code>ACCESS</code>数据导出为Excel文件，然后导入到公司电脑上。这也算是一种曲线救国的方式了。  </p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Access </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用ADO导入CSV后部分数据变成NULL，怎么破？</title>
      <link href="/2018/06/20/ADO-Text-Driver-Data-Type/"/>
      <url>/2018/06/20/ADO-Text-Driver-Data-Type/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>最近要处理一些数据量比较大的CSV文件，本着能不用<code>ACCESS</code>就不用<code>ACCESS</code>的原则，使用了<code>VBA</code>+<code>ADO</code>联用的方法。  </p><blockquote><p>CSV，Comma Separated Value，是一种用逗号分隔不同的值，来保存数据的文本文件  </p></blockquote><blockquote><p>ADO, Active Data Object，可以简单的看作是操作数据库的接口 </p></blockquote><h2 id="出现了什么问题？"><a href="#出现了什么问题？" class="headerlink" title="出现了什么问题？"></a>出现了什么问题？</h2><p>首先要做的一步是把<code>CSV</code>中的数据读取到工作表里。鉴于这不是一篇入门的文章，我们就不在这里介绍基础内容了。  </p><p>现有的<code>p.csv</code>文件是这个样子：    </p><p><img src="http://www.doublure.cn/blog/180620/FJJ1bKaeH4.png?imageslim" alt="mark"></p><p>用下面的这段程序，可以直接把<code>CSV</code>中的数据读入到工作表里。  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Option</span> <span class="keyword">Explicit</span></span><br><span class="line"><span class="keyword">Sub</span> main()</span><br><span class="line">    LoadData <span class="string">"p.csv"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Private</span> <span class="keyword">Sub</span> LoadData(strCSVPath <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    <span class="keyword">Dim</span> strSQL <span class="keyword">As</span> <span class="built_in">String</span>, strConnection <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    <span class="keyword">Dim</span> oRst <span class="keyword">As</span> ADODB.Recordset</span><br><span class="line">    </span><br><span class="line">    strConnection = <span class="string">"Provider=Microsoft.ace.oledb.12.0;"</span> &amp; _</span><br><span class="line">                    <span class="string">"Data Source="</span> &amp; ThisWorkbook.Path &amp; <span class="string">";"</span> &amp; _</span><br><span class="line">                    <span class="string">"Extended Properties= 'text;HDR=Yes;IMEX=1;FMT=Delimited(,)';"</span></span><br><span class="line">    <span class="keyword">Set</span> oRst = <span class="keyword">New</span> ADODB.Recordset</span><br><span class="line">    strSQL = <span class="string">"SELECT * FROM "</span> &amp; strCSVPath</span><br><span class="line">    oRst.Open strSQL, strConnection, adOpenStatic, adLockReadOnly</span><br><span class="line">    Sheet1.Range(<span class="string">"a1"</span>).CopyFromRecordset oRst</span><br><span class="line">    oRst.Close</span><br><span class="line">    <span class="keyword">Set</span> oRst = <span class="literal">Nothing</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>上面这段代码，可以把当前工作簿目录下的<code>p.csv</code>中的数据内容导入到sheet1工作表里。<br>查看sheet1工作表，发现一个问题：有些单元格是空的，比如第189，195,196行。  </p><p><img src="http://www.doublure.cn/blog/180620/cfh4lme6fK.png?imageslim" alt="mark"></p><p>再返回到源文件查看对应的行，第一眼看上去是有数据的啊，见下图：</p><p><img src="http://www.doublure.cn/blog/180620/9cklHmjD3a.png?imageslim" alt="mark">  </p><p>又重复运行了几次脚本，复制出来的数据始终有空行，百思不得其解。  </p><h2 id="原因在哪里？"><a href="#原因在哪里？" class="headerlink" title="原因在哪里？"></a>原因在哪里？</h2><p>又盯着看了一会，似乎看出了点端倪。不能被显示出来的数据貌似都很大，都是<code>E9</code>数量级。但看第188行，<code>1.22E9</code>是可以正常显示的。  </p><p>感觉显示为空单元的数字都太大了，所以没有显示出来。经过LEAF大神的提醒，可以使用<code>Fields.Type</code>来查看数据类型。上面的代码修改为：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Option</span> <span class="keyword">Explicit</span></span><br><span class="line"><span class="keyword">Sub</span> main()</span><br><span class="line">    LoadData <span class="string">"p.csv"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Private</span> <span class="keyword">Sub</span> LoadData(strCSVPath <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    <span class="keyword">Dim</span> strSQL <span class="keyword">As</span> <span class="built_in">String</span>, strConnection <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    <span class="keyword">Dim</span> oRst <span class="keyword">As</span> ADODB.Recordset</span><br><span class="line">    <span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line">    strConnection = <span class="string">"Provider=Microsoft.ace.oledb.12.0;"</span> &amp; _</span><br><span class="line">                    <span class="string">"Data Source="</span> &amp; ThisWorkbook.Path &amp; <span class="string">";"</span> &amp; _</span><br><span class="line">                    <span class="string">"Extended Properties= 'text;HDR=Yes;IMEX=1;FMT=Delimited(,)';"</span></span><br><span class="line">    <span class="keyword">Set</span> oRst = <span class="keyword">New</span> ADODB.Recordset</span><br><span class="line">    strSQL = <span class="string">"SELECT * FROM "</span> &amp; strCSVPath</span><br><span class="line">    oRst.Open strSQL, strConnection, adOpenStatic, adLockReadOnly</span><br><span class="line">    <span class="comment">'以下为新增代码</span></span><br><span class="line">    <span class="comment">'========</span></span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">0</span> <span class="keyword">To</span> oRst.Fields.Count - <span class="number">1</span></span><br><span class="line">        Debug.Print oRst.Fields(i).Type, oRst.Fields(i).Name</span><br><span class="line">    <span class="keyword">Next</span> i</span><br><span class="line">    <span class="comment">'========</span></span><br><span class="line">    <span class="comment">'以上为新增代码</span></span><br><span class="line">    Sheet1.Range(<span class="string">"a1"</span>).CopyFromRecordset oRst</span><br><span class="line">    oRst.Close</span><br><span class="line">    <span class="keyword">Set</span> oRst = <span class="literal">Nothing</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>到立即窗口查看，打印出了下面的内容：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">202 </span>      账户简称</span><br><span class="line"><span class="symbol">3 </span>        金额（元）</span><br><span class="line"><span class="symbol">7 </span>        结算日期</span><br></pre></td></tr></table></figure></p><p>也就是说，金额字段对应的数据类型是3。数据类型3又是什么呢？直接在msdn上搜索一下，发现<a href="https://docs.microsoft.com/en-us/sql/ado/reference/ado-api/datatypeenum?view=sql-server-2017" target="_blank" rel="noopener">这个页面</a>里说的很清楚：  </p><p><img src="http://www.doublure.cn/blog/180620/i22f12jchA.png?imageslim" alt="mark">  </p><p>3对应的是4个字节的正负整数。4个字节大约可以表示从<code>-2^31</code>到<code>2^31</code>之间，大约是<code>-2.15E9</code>到<code>2.15E9</code>。难怪<code>4.7E9</code>显示不出来，因为变量长度溢出了啊。  </p><h2 id="为什么会出现这个问题？"><a href="#为什么会出现这个问题？" class="headerlink" title="为什么会出现这个问题？"></a>为什么会出现这个问题？</h2><p>在用ADO读取文本文件的时候，因为文本文件中的数据格式没有被显式指定，所以ADO的文本引擎会先扫描一定的行数，然后给每列推测一个数据类型。  </p><p>很显然，文中出现的问题就是因为ADO扫描完之后，指定了一个<code>adInteger</code>类型，但后面出现的大的数字已经超出了范围。  </p><p>那么，ADO会扫描多少行呢？<br>在网上搜了一下，在这个注册表下面有ADO文本引擎的默认设置：<br><code>[Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Jet\4.0\Engines\Text]</code></p><p><img src="http://www.doublure.cn/blog/180620/Db41eFFBbK.png?imageslim" alt="mark">  </p><p>很明显，MaxScanRows的值是25，也就是说Text引擎会扫描25行，然后根据扫描结果指定一个数据类型。  </p><h2 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h2><p>有两种方法。  </p><p>第一种方法不太推荐，就是直接修改注册表，把<code>MaxScanRows</code>的值修改为足够大。如果想扫描全部内容，就把<code>MaxScanRows</code>的值改为0。  </p><p>第二种方法更加安全一些，也就是用一个文件<code>Schema.ini</code>来存储文本文件的信息。  </p><p><code>Schema.ini</code>一定要与<code>CSV</code>文件在同一个目录下，他包含了下面这些信息：  </p><ul><li>文件名  </li><li>文件格式  </li><li>字段名</li><li>字符集</li><li>等等  </li></ul><p>详细的格式设置可以查看<a href="https://docs.microsoft.com/en-us/sql/odbc/microsoft/schema-ini-file-text-file-driver?view=sql-server-2017" target="_blank" rel="noopener">这个链接</a>  </p><p>在这个例子里，我们就在<code>p.csv</code>所在的文件夹创建<code>Schema.ini</code>，然后简单的指定下面的内容即可。  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[p.csv]</span></span><br><span class="line"><span class="attr">Format</span> = CSVDelimited</span><br><span class="line"><span class="attr">ColNameHeader</span> = <span class="literal">True</span></span><br><span class="line"><span class="attr">MaxScanRows</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当然，我们也可以把创建文件的内容加入到<code>ADO</code>脚本里，最后完整的脚本内容就会变成：  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Option</span> <span class="keyword">Explicit</span></span><br><span class="line"><span class="keyword">Sub</span> main()</span><br><span class="line">    CreateIniFile <span class="string">"p.csv"</span></span><br><span class="line">    LoadData <span class="string">"p.csv"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Private</span> <span class="keyword">Sub</span> LoadData(strCSVPath <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    <span class="keyword">Dim</span> strSQL <span class="keyword">As</span> <span class="built_in">String</span>, strConnection <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    <span class="keyword">Dim</span> oRst <span class="keyword">As</span> ADODB.Recordset</span><br><span class="line">    <span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line">    strConnection = <span class="string">"Provider=Microsoft.ace.oledb.12.0;"</span> &amp; _</span><br><span class="line">                    <span class="string">"Data Source="</span> &amp; ThisWorkbook.Path &amp; <span class="string">";"</span> &amp; _</span><br><span class="line">                    <span class="string">"Extended Properties= 'text;HDR=Yes;IMEX=1;FMT=Delimited(,)';"</span></span><br><span class="line">    <span class="keyword">Set</span> oRst = <span class="keyword">New</span> ADODB.Recordset</span><br><span class="line">    strSQL = <span class="string">"SELECT * FROM "</span> &amp; strCSVPath</span><br><span class="line">    oRst.Open strSQL, strConnection, adOpenStatic, adLockReadOnly</span><br><span class="line">    Sheet1.Range(<span class="string">"a1"</span>).CopyFromRecordset oRst</span><br><span class="line">    oRst.Close</span><br><span class="line">    <span class="keyword">Set</span> oRst = <span class="literal">Nothing</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Private</span> <span class="keyword">Sub</span> CreateIniFile(strCSVPath <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    <span class="keyword">Dim</span> iFreeFile <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line">    <span class="keyword">Dim</span> StrIni <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    </span><br><span class="line">    StrIni = <span class="string">"["</span> &amp; strCSVPath &amp; <span class="string">"]"</span> &amp; vbCrLf &amp; _</span><br><span class="line">                    <span class="string">"Format = CSVDelimited"</span> &amp; vbCrLf &amp; _</span><br><span class="line">                    <span class="string">"ColNameHeader = True"</span> &amp; vbCrLf &amp; _</span><br><span class="line">                    <span class="string">"MaxScanRows = 0"</span></span><br><span class="line">    </span><br><span class="line">    iFreeFile = FreeFile</span><br><span class="line">    </span><br><span class="line">    Open ThisWorkbook.Path &amp; <span class="string">"\Schema.ini"</span> <span class="keyword">For</span> Output <span class="keyword">As</span> <span class="meta">#iFreeFile</span></span><br><span class="line">    Print <span class="meta">#iFreeFile, StrIni</span></span><br><span class="line">    Close <span class="meta">#iFreeFile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>再次运行程序，发现之前的空白单元格已经有数字进来了：  </p><p><img src="http://www.doublure.cn/blog/180620/L39DBI9i4c.png?imageslim" alt="mark">  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>VBA</code>还是要多查<code>MSDN</code>  </li><li><code>ADO</code>里的<code>Field</code>的基本属性要熟练</li></ul>]]></content>
      
      <categories>
          
          <category> VBA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用scrapy爬取职位信息</title>
      <link href="/2018/06/15/%E7%94%A8scrapy%E7%88%AC%E5%8F%96%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/06/15/%E7%94%A8scrapy%E7%88%AC%E5%8F%96%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>​    </p><a id="more"></a><p>新开一篇，来讲解一个<code>51JOB</code>工作职位的爬取。<br>目标：<br>爬取<code>51JOB</code>上所有与化工相关的职位信息。  </p><p>工具：<br><code>scrapy</code>框架+<code>Python3</code>  </p><h2 id="第一步：安装环境"><a href="#第一步：安装环境" class="headerlink" title="第一步：安装环境"></a>第一步：安装环境</h2><p>使用：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -<span class="selector-tag">p</span> /usr/bin/python3 scrapy_env</span><br></pre></td></tr></table></figure><p>来创建一个新的虚拟环境来运行<code>scrapy</code>  </p><p>cd到<code>scrapy_env</code>文件夹，然后执行下面语句来开启虚拟空间：  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/scrapy_env$ source bin/<span class="built_in">activate</span></span><br></pre></td></tr></table></figure><p>进入到<code>scrapy_env</code>的虚拟空间后，用<code>pip3 install scrapy</code>来安装<code>scrapy</code>所需要的依赖  </p><h2 id="创建Scrapy项目"><a href="#创建Scrapy项目" class="headerlink" title="创建Scrapy项目"></a>创建<code>Scrapy</code>项目</h2><p>使用<code>scrapy startproject</code>来创建项目。   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy startproject 51job</span><br><span class="line">Error: Project names must <span class="keyword">begin</span> <span class="keyword">with</span> a letter <span class="keyword">and</span> contain <span class="keyword">only</span></span><br><span class="line">letters, numbers <span class="keyword">and</span> underscores</span><br><span class="line">~$ scrapy startproject jobs</span><br><span class="line"><span class="keyword">New</span> Scrapy <span class="keyword">project</span> <span class="string">'jobs'</span>, <span class="keyword">using</span> <span class="keyword">template</span> <span class="keyword">directory</span> <span class="string">'/home/ubuntu/scrapy_env/lib/python3.5/site-packages/scrapy/templates/project'</span>, created <span class="keyword">in</span>:</span><br><span class="line">    /home/ubuntu/jobs</span><br><span class="line"></span><br><span class="line">You can <span class="keyword">start</span> your <span class="keyword">first</span> spider <span class="keyword">with</span>:</span><br><span class="line">    cd jobs</span><br><span class="line">    scrapy genspider example example.com</span><br></pre></td></tr></table></figure><p>然后使用<code>scrapy genspider</code>来创建一个爬虫  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/jobs$ scrapy genspider JobSpider search.<span class="number">51</span>job.com</span><br><span class="line">Created spider <span class="string">'JobSpider'</span> using template <span class="string">'basic'</span> <span class="keyword">in</span> module:</span><br><span class="line">  jobs<span class="selector-class">.spiders</span><span class="selector-class">.JobSpider</span></span><br></pre></td></tr></table></figure><p>这样，项目的框架就搭好了。现在整个项目的目录文件应该是这样子的：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── jobs</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── items.py</span><br><span class="line">│   ├── middlewares.py</span><br><span class="line">│   ├── pipelines.py</span><br><span class="line">│   ├── __pycache__</span><br><span class="line">│   │   ├── __init__<span class="selector-class">.cpython-35</span><span class="selector-class">.pyc</span></span><br><span class="line">│   │   └── settings<span class="selector-class">.cpython-35</span><span class="selector-class">.pyc</span></span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   └── spiders</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       ├── JobSpider.py</span><br><span class="line">│       └── __pycache__</span><br><span class="line">└── scrapy.cfg</span><br></pre></td></tr></table></figure><h2 id="编辑Scrapy文件"><a href="#编辑Scrapy文件" class="headerlink" title="编辑Scrapy文件"></a>编辑<code>Scrapy</code>文件</h2><p><code>Scrapy</code>框架极大程度的减少了我们爬虫额代码编写量。对于一个简单的爬虫，我们只需要修改下面几个内容。 </p><p>首次得打开网页链接：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http<span class="variable">s:</span>//<span class="built_in">search</span>.<span class="number">51</span>job.<span class="keyword">com</span>/<span class="keyword">list</span>/<span class="number">000000</span>,<span class="number">000000</span>,<span class="number">0000</span>,<span class="number">19</span>,<span class="number">9</span>,<span class="number">99</span>,%<span class="number">2</span>B,<span class="number">2</span>,<span class="number">1</span>.html?lang=<span class="keyword">c</span>&amp;stype=<span class="number">1</span>&amp;postchannel=<span class="number">0000</span>&amp;workyear=<span class="number">99</span>&amp;cotype=<span class="number">99</span>&amp;degreefrom=<span class="number">99</span>&amp;jobterm=<span class="number">99</span>&amp;companysize=<span class="number">99</span>&amp;lonlat=<span class="number">0</span>%<span class="number">2</span>C0&amp;radius=-<span class="number">1</span>&amp;ord_field=<span class="number">0</span>&amp;confirmdate=<span class="number">9</span>&amp;fromType=<span class="number">1</span>&amp;dibiaoid=<span class="number">0</span>&amp;address=&amp;<span class="built_in">line</span>=&amp;specialarea=<span class="number">00</span>&amp;from=&amp;welfare=</span><br></pre></td></tr></table></figure></p><h3 id="items-py"><a href="#items-py" class="headerlink" title="items.py"></a><code>items.py</code></h3><p>我们需要获取的每一条招聘内容包括了下面这些信息：  </p><ul><li>职位名</li><li>公司名</li><li>工作地点</li><li>薪资</li><li>发布时间<br>因此，我们需要根据这些来定义一个<code>Item</code>，也就是一条爬取下来的信息。  </li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import <span class="keyword">scrapy</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">class </span><span class="keyword">JobsItem(scrapy.Item):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    <span class="keyword">job_title </span>= <span class="keyword">scrapy.Field()</span></span><br><span class="line"><span class="keyword"> </span>   company = <span class="keyword">scrapy.Field()</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">job_href </span>= <span class="keyword">scrapy.Field()</span></span><br><span class="line"><span class="keyword"> </span>   location = <span class="keyword">scrapy.Field()</span></span><br><span class="line"><span class="keyword"> </span>   salary = <span class="keyword">scrapy.Field()</span></span><br><span class="line"><span class="keyword"> </span>   post_date = <span class="keyword">scrapy.Field()</span></span><br></pre></td></tr></table></figure><p>这就好了，讲白了，我们是定义了一个名字叫<code>JobItem</code>的字典，然后给这个字典定义了5个键。  </p><h3 id="spiders-JobSpider-py"><a href="#spiders-JobSpider-py" class="headerlink" title="spiders/JobSpider.py"></a><code>spiders/JobSpider.py</code></h3><p>确定了我们要获取的信息，我们就可以处理爬虫了。  </p><p>爬取51job其实非常简单，我们只需要输入指定的关键字，然后点搜索，把返回的网页网址作为起始网址即可。  </p><p>然后要遵循下面的这个思路：</p><ul><li>爬某个页面</li><li>把我们所需要的字段信息装载到<code>item</code>里，后面我们要通过<code>pipeline</code>来进行处理</li><li>找到<code>下一页</code>的<code>anchor</code>标签的链接地址</li><li>如果能找到<code>下一页</code>的话，就递归回到第一步</li></ul><p>在解析页面的时候，需要用到<code>scrapy</code>的<code>selector</code>对象的<code>xpath</code>方法。<code>xpath</code>相对于<code>css</code>选择器来说更加复杂一些，但解析效率更高。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> jobs.items <span class="keyword">import</span> JobsItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobspiderSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name=<span class="string">'jobspider'</span></span><br><span class="line">    allowed_domains = [<span class="string">'search.51job.com'</span>]</span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">'http://search.51job.com/list/000000,000000,0000,19,9,99,%2B,2,1.html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=1&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare='</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">        next_page_url = response.xpath(<span class="string">'//li[@class="bk"][2]/a/@href'</span>)</span><br><span class="line">        job_list = response.xpath(<span class="string">'//*[@id="resultList"]/div[@class="el"]'</span>)</span><br><span class="line">        <span class="keyword">for</span> each_job <span class="keyword">in</span> job_list:</span><br><span class="line">            job_info = JobsItem()</span><br><span class="line">            job_info[<span class="string">'job_title'</span>] = each_job.xpath(<span class="string">'.//p[contains(@class,"t1")]/span/a/text()'</span>)</span><br><span class="line">            job_info[<span class="string">'company'</span>] = each_job.xpath(<span class="string">'.//span[contains(@class,"t2")]/a/text()'</span>)</span><br><span class="line">            job_info[<span class="string">'job_href'</span>] = each_job.xpath(<span class="string">'.//span[contains(@class,"t2")]/a/@href'</span>)</span><br><span class="line">            job_info[<span class="string">'location'</span>] = each_job.xpath(<span class="string">'.//span[contains(@class,"t3")]/text()'</span>)</span><br><span class="line">            job_info[<span class="string">'salary'</span>] = each_job.xpath(<span class="string">'.//span[contains(@class,"t4")]/text()'</span>)</span><br><span class="line">            job_info[<span class="string">'post_date'</span>] = each_job.xpath(<span class="string">'.//span[contains(@class,"t5")]/text()'</span>) <span class="comment"># mm-dd</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> job_info.items():</span><br><span class="line">                <span class="keyword">if</span> v:</span><br><span class="line">                    job_info[k] = v.extract_first().strip()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    job_info[k] = <span class="string">'unknown'</span></span><br><span class="line">            <span class="keyword">yield</span> job_info</span><br><span class="line">        <span class="keyword">if</span> next_page_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            abs_url = next_page_url.extract_first().strip()</span><br><span class="line">            <span class="keyword">yield</span> response.follow(abs_url, callback=self.parse)</span><br></pre></td></tr></table></figure><h3 id="pipelines-py"><a href="#pipelines-py" class="headerlink" title="pipelines.py"></a><code>pipelines.py</code></h3><p><code>pipelines</code>用来处理<code>scrapy</code>爬取完页面然后解析出来的<code>item</code>。可以这么理解，<code>pipelines</code>把<code>item</code>处理完之后，会装入到数据库里去。<br>在这里，我们要把数据装入到<code>MYSQL</code>数据库里，并且先不考虑去重等要求。  </p><blockquote><p>这需要在<code>MySQL</code>中先建立好<code>DATABASE</code>以及<code>TABLE</code>。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">import pymysql</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobsPipeline</span>(<span class="title">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.database = pymysql.connect(host=<span class="string">'localhost'</span>,</span><br><span class="line">                                  port=<span class="number">3306</span>,</span><br><span class="line">                                  user=<span class="string">'xxxxxx'</span>,</span><br><span class="line">                                  passwd=<span class="string">'xxxxxx'</span>,</span><br><span class="line">                                  db=<span class="string">'job_info'</span>,</span><br><span class="line">                                  charset=<span class="string">'utf8'</span>)</span><br><span class="line">        <span class="keyword">self</span>.cursor = <span class="keyword">self</span>.database.cursor()</span><br><span class="line">        <span class="keyword">self</span>.table = <span class="string">'jobs'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(<span class="keyword">self</span>, item, spider)</span></span><span class="symbol">:</span></span><br><span class="line"></span><br><span class="line">        sql_string = <span class="string">'INSERT INTO &#123;&#125; (job_title, company, job_href, location, salary, post_date, update_datetime)  \</span></span><br><span class="line"><span class="string">                VALUES("&#123;&#125;","&#123;&#125;","&#123;&#125;","&#123;&#125;","&#123;&#125;","&#123;&#125;",str_to_date("&#123;&#125;","%Y-%m-%d %H:%i:%s"));'</span> \</span><br><span class="line">            .format(<span class="keyword">self</span>.table, item[<span class="string">'job_title'</span>], item[<span class="string">'company'</span>], item[<span class="string">'job_href'</span>],</span><br><span class="line">                    item[<span class="string">'location'</span>], item[<span class="string">'salary'</span>], item[<span class="string">'post_date'</span>],</span><br><span class="line">                    datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">        <span class="symbol">try:</span></span><br><span class="line">            <span class="keyword">self</span>.cursor.execute(sql_string)</span><br><span class="line">            <span class="keyword">self</span>.database.commit()</span><br><span class="line">        <span class="symbol">except:</span></span><br><span class="line">            print(<span class="string">'error'</span>)</span><br><span class="line">            <span class="keyword">self</span>.database.rollback()</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a><code>settings.py</code></h3><p>完成上面的处理之后，我们还需要做最后一步，修改<code>settings.py</code>，也就是项目设置。  </p><p>最主要的是两件事情：  </p><ul><li>设置默认的请求头<br>设置默认的请求头很简单，只需要找到，修改为下面的内容即可。  </li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',</span><br><span class="line">    'Accept-Language': 'en-US,en;q=0.9',</span><br><span class="line">    'Connection':'keep-alive',</span><br><span class="line">    'Cookie':'your-cookie-here',</span><br><span class="line">    'Host':'search.51job.com',</span><br><span class="line">    'Referer':'http://search.51job.com/list/<span class="number">000000</span>,<span class="number">000000</span>,<span class="number">0000</span>,19,9,99,%2B,2,2.html?lang=c&amp;stype=1&amp;postchannel=<span class="number">0000</span>&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=1&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=%27',</span><br><span class="line">    'Upgrade-Insecure-Requests':'1',</span><br><span class="line">    'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/65.0.<span class="number">3325.18</span>1 Chrome/65.0.<span class="number">3325.18</span>1 Safari/537.36',</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那上面这些内容是从哪来的呢？当然是从<code>Chrome</code>浏览器的<code>Request Headers</code>的信息拿出来的。  </p><ul><li>开启<code>pipelines</code><br>这个也很简单，把下面这句取消注释即可。  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   'jobs.pipelines.JobsPipeline': 300,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最终运行"><a href="#最终运行" class="headerlink" title="最终运行"></a>最终运行</h2><p>cd到项目的根目录下，注意一定要是根目录，然后执行：  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">scrapy crawl jobspider</span></span><br></pre></td></tr></table></figure><p>至此，一个最简单的<code>Scrapy</code>爬虫就写好了。<br>后期还有很多细节要处理，比如数据去重，异常处理，数据分析等等，不过这些我们可以在后面优化，后面我们也会陆续讲解。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
